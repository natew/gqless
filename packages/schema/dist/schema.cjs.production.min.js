'use strict'
Object.defineProperty(exports, '__esModule', { value: !0 })
var e = require('gqless')
const n = 'gqless',
  t = '@gqless/utils'
class s {
  constructor(e, n = !0) {
    ;(this.path = e),
      (this.overwrite = n),
      (this.imports = new Map()),
      (this.importAlls = new Map())
  }
  import(e, ...n) {
    this.imports.has(e) || this.imports.set(e, new Set())
    const t = this.imports.get(e)
    n.forEach(e => t.add(e))
  }
  importAll(e, n) {
    if (this.importAlls.has(e)) {
      const t = this.importAlls.get(e)
      if (t !== n)
        throw new Error(
          `Already imported all from ${e}, use ${t} instead of ${n}`
        )
    } else this.importAlls.set(e, n)
  }
  generate() {
    return [
      ...Array.from(this.importAlls.entries()).map(
        ([e, n]) => `import * as ${n} from '${e}'`
      ),
      ...Array.from(this.imports.entries()).map(([e, n]) =>
        n.size ? `import { ${Array.from(n).join(',')} } from '${e}'` : ''
      ),
    ].join('\n')
  }
}
const r = 'schema'
class a extends s {
  constructor(e) {
    super('generated/schema'), (this.codegen = e)
  }
  generate() {
    this.importAll('../extensions', 'extensions'), this.import(t, 'lazyGetters')
    const e = `\n      export const ${r} = ${this.generateSchema()}\n\n      lazyGetters(${r})\n    `
    return `\n      // @ts-nocheck\n      ${super.generate()}\n\n      ${e}\n    `
  }
  generateSchema() {
    return `{\n      ${Object.values(this.codegen.schema.types)
      .map(
        e =>
          `get ${e.name}() {\n            return ${this.generateNode(
            e
          )}\n          }`
      )
      .join(',')}\n    }`
  }
  getNode(e) {
    return `${r}.${e}`
  }
  getExtension(e) {
    return this.codegen.options.typescript
      ? `(extensions as any || {}).${e}`
      : `(extensions || {}).${e}`
  }
  generateFieldGetter(t) {
    return (
      this.import(n, e.FieldNode.name),
      `get ${t.name}() {\n      return new ${
        e.FieldNode.name
      }(${this.generateType(t.type)}, ${this.generateArguments(t.args)}, ${
        t.type.nullable
      })\n    }`
    )
  }
  generateNode(t) {
    switch (t.kind) {
      case 'OBJECT':
        return (
          this.import(n, e.ObjectNode.name),
          `new ${e.ObjectNode.name}({\n          ${Object.values(t.fields)
            .map(e => this.generateFieldGetter(e))
            .join(',')}\n        }, { name: ${JSON.stringify(
            t.name
          )}, extension: ${this.getExtension(t.name)} })`
        )
      case 'INTERFACE':
        return (
          this.import(n, e.InterfaceNode.name),
          `new ${e.InterfaceNode.name}({\n          ${Object.values(t.fields)
            .map(e => this.generateFieldGetter(e))
            .join(',')}\n        },\n        [${t.possibleTypes
            .map(e => this.getNode(e))
            .join(',')}],\n        { name: ${JSON.stringify(
            t.name
          )}, extension: ${this.getExtension(t.name)} })`
        )
      case 'UNION':
        return (
          this.import(n, e.UnionNode.name),
          `new ${e.UnionNode.name}([${t.possibleTypes.map(e =>
            this.getNode(e)
          )}])`
        )
      case 'SCALAR':
        return (
          this.import(n, e.ScalarNode.name),
          `new ${e.ScalarNode.name}({ name: ${JSON.stringify(
            t.name
          )}, extension: ${this.getExtension(t.name)} })`
        )
      case 'INPUT_OBJECT':
        return (
          this.import(n, e.InputNode.name),
          `new ${e.InputNode.name}({\n          ${Object.values(t.inputFields)
            .map(
              t => (
                this.import(n, e.InputNodeField.name),
                `get ${t.name}() {\n                return new ${
                  e.InputNodeField.name
                }(${this.generateType(t.type)}, ${
                  t.type.nullable
                })\n              }`
              )
            )
            .join(',')}\n        }, ${JSON.stringify({ name: t.name })})`
        )
      case 'ENUM':
        return (
          this.import(n, e.EnumNode.name),
          `new ${e.EnumNode.name}({ name: ${JSON.stringify(t.name)} })`
        )
    }
  }
  generateType(t) {
    return (
      this.import(n, e.ArrayNode.name),
      'LIST' === t.kind
        ? `new ${e.ArrayNode.name}(${this.generateType(t.ofType)}, ${
            t.nullable
          })`
        : this.getNode(t.name)
    )
  }
  generateArguments(t) {
    if (!t) return
    this.import(n, e.Arguments.name)
    const s = Object.values(t).find(e => e.nullable) ? '' : ', true'
    return `new ${e.Arguments.name}({\n      ${Object.entries(t)
      .map(
        ([t, s]) => (
          this.import(n, e.ArgumentsField.name),
          `get ${t}() {\n            return new ${
            e.ArgumentsField.name
          }(${this.generateType(s)}, ${s.nullable})}`
        )
      )
      .join(',')}\n    }${s})`
  }
}
const i = 't_'
class o extends s {
  constructor(e) {
    super('generated/types'),
      (this.codegen = e),
      (this.typeNames = this.createUniqueNames(
        Object.keys(this.codegen.schema.types),
        Object.keys(this.codegen.schema.types),
        e => `${i}${e}`
      )),
      (this.names = this.createUniqueNames(
        [
          ...Object.keys(this.codegen.schema.types),
          ...Object.values(this.typeNames),
        ],
        [
          'Extension',
          'EnumType',
          'FieldsType',
          'FieldsTypeArg',
          'ScalarType',
          'TypeData',
          'extensions',
        ],
        e => `gqless_${e}`
      )),
      (this.typeReference = e =>
        'INPUT_OBJECT' === this.codegen.getSchemaType(e).kind
          ? e
          : this.typeNames[e]),
      (this.typeValue = e => {
        const n = this.codegen.getSchemaType(e)
        return 'SCALAR' === n.kind ? this.defaultScalarType(n) : n.name
      })
  }
  createUniqueNames(e, n, t) {
    const s = {},
      r = n => (e.includes(n) ? r(t(n)) : n)
    for (const t of n) {
      const n = r(t)
      e.push(n), (s[t] = n)
    }
    return s
  }
  generate() {
    this.import(n, this.names.TypeData),
      this.importAll('../extensions', this.names.extensions)
    const e = Object.values(this.codegen.schema.types)
      .map(e => {
        const n = this.generateSchemaType(e)
        if (n) return this.generateComments(this.schemaTypeComments(e)) + n
      })
      .filter(Boolean)
      .join('\n\n')
    return `\n      ${super.generate()}\n\n      type ${
      this.names.Extension
    }<TName extends string> = TName extends keyof typeof ${
      this.names.extensions
    }\n        ? typeof ${
      this.names.extensions
    }[TName]\n        : any\n\n      ${e}\n\n      ${Object.values(
      this.codegen.schema.types
    )
      .filter(e => 'INPUT_OBJECT' !== e.kind)
      .map(e =>
        'ENUM' === e.kind
          ? `${this.generateComments(this.schemaTypeComments(e))}export enum ${
              e.name
            } { \n\n          ${e.enumValues.map(
              e => `${e} = '${e}' \n`
            )}\n          }`
          : `${this.generateComments(this.schemaTypeComments(e))}export type ${
              e.name
            } = ${this.names.TypeData}<${this.typeReference(e.name)}>`
      )
      .join('\n')}\n    `
  }
  schemaTypeComments(e) {
    const n = [`@name ${e.name}`, `@type ${e.kind}`]
    return (
      'OBJECT' === e.kind &&
        e.interfaces.length &&
        n.push(`@implements ${e.interfaces.join(', ')}`),
      n
    )
  }
  generateComments(e) {
    return e.length
      ? '\n/**\n' + ` * ${e.join('\n* ').replace(/\*\//gm, '*â€‹/')}\n` + ' */\n'
      : ''
  }
  generateFieldComments(e) {
    const n = []
    return (
      e.isDeprecated &&
        n.push(
          `@deprecated${
            e.deprecationReason
              ? ` ${e.deprecationReason.replace(/\n/gm, ' ')}`
              : ''
          }`
        ),
      e.description && n.push(...e.description.split('\n')),
      this.generateComments(n)
    )
  }
  generateSchemaType(e) {
    switch (e.kind) {
      case 'SCALAR':
        return this.generateScalarType(e)
      case 'UNION':
      case 'INTERFACE':
        return `type ${this.typeReference(e.name)} = ${e.possibleTypes
          .map(e => this.typeReference(e))
          .join(' | ')}`
      case 'OBJECT':
        return (
          this.import(n, this.names.FieldsType),
          `type ${this.typeReference(e.name)} = ${this.names.FieldsType}<{\n${[
            `__typename: ${this.typeReference('String')}<'${e.name}'>`,
            ...Object.values(e.fields).map(e => this.generateField(e)),
          ].join('\n')}\n}, ${this.names.Extension}<'${e.name}'>>`
        )
      case 'INPUT_OBJECT':
        return `export type ${this.typeReference(e.name)} = {${Object.values(
          e.inputFields
        )
          .map(e => this.generateField(e, this.typeValue))
          .join('\n')}}`
      case 'ENUM':
        return (
          this.import(n, this.names.EnumType),
          `type ${this.typeReference(e.name)} = ${
            this.names.EnumType
          }<${e.enumValues.map(e => `'${e}'`).join(' | ')}>`
        )
      default:
        return
    }
  }
  generateArgs(e) {
    return `{${Object.entries(e)
      .map(
        ([e, n]) =>
          `${e}${n.nullable ? '?' : ''}: ${this.generateType(
            n,
            this.typeValue
          )}`
      )
      .join(',')}}`
  }
  generateField(e, t) {
    const s = e.type.nullable ? '?' : '',
      r = this.generateType(e.type, t)
    return (
      e.args && this.import(n, this.names.FieldsTypeArg),
      `${this.generateFieldComments(e)}${e.name} ${
        e.args
          ? `: ${this.names.FieldsTypeArg}<${this.generateArgs(e.args)}, ${r}>`
          : `${s}: ${r}`
      }`
    )
  }
  generateType(e, n = this.typeReference) {
    const t = e.nullable ? '| null' : ''
    switch (e.kind) {
      case 'OBJECT':
      case 'ENUM':
      case 'INPUT_OBJECT':
      case 'UNION':
      case 'INTERFACE':
      case 'SCALAR':
        return `${n(e.name)}${t}`
      case 'LIST':
        return `(${this.generateType(e.ofType, n)})[]${t}`
      default:
        return 'any'
    }
  }
  defaultScalarType(e) {
    switch (e.name) {
      case 'ID':
      case 'String':
      case 'Date':
      case 'URI':
        return 'string'
      case 'Int':
      case 'Float':
        return 'number'
      case 'Boolean':
        return 'boolean'
      case 'JSON':
        return '{ [K: string]: any }'
    }
    return 'any'
  }
  generateScalarType(e) {
    this.import(n, this.names.ScalarType)
    const t = this.defaultScalarType(e)
    return `type ${this.typeReference(e.name)}<T extends ${t} = ${t}> = ${
      this.names.ScalarType
    }<T, ${this.names.Extension}<'${e.name}'>>`
  }
}
class p extends s {
  constructor() {
    super('generated/index')
  }
  generate() {
    return `\n      ${super.generate()}\n\n      export * from './schema'\n      export * from './types'\n    `
  }
}
class m extends s {
  constructor(e) {
    super('extensions/index', !1), (this.codegen = e)
  }
  generate() {
    return `\n      ${super.generate()}\n\n      export const Query = {}\n\n      /**\n       * Add a key to a type\n       */\n      // export const User = {\n      //   [GET_KEY]: (user) => user.id\n      // }\n\n      /**\n       * Add custom data to a type\n       * @example\n       * query.users[0].follow()\n       */\n      // export const User = (user) => ({\n      //   follow() {\n      //     console.log('follow', user.id)\n      //   }\n      // })\n    `
  }
}
class c extends s {
  constructor(e) {
    super('client', !1), (this.codegen = e)
  }
  generate() {
    return (
      this.import(n, 'Client', 'QueryFetcher'),
      this.import('./generated', 'schema', this.codegen.schema.queryType),
      `\n      ${super.generate()}\n\n      const endpoint = ${JSON.stringify(
        this.codegen.options.url || ''
      )}\n\n      const fetchQuery: QueryFetcher = async (query, variables) => {\n        const response = await fetch(endpoint, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',${
        this.codegen.options.headers
          ? Object.entries(this.codegen.options.headers)
              .map(([e, n]) => `'${e}': '${n}'`)
              .join('\n')
          : ''
      }\n          },\n          body: JSON.stringify({\n            query,\n            variables,\n          }),\n          mode: 'cors',\n        })\n\n        if (!response.ok) {\n          throw new Error(\`Network error, received status code \${response.status}\`)\n        }\n\n        const json = await response.json()\n\n        return json\n      }\n\n      export const client = new Client<${
        this.codegen.schema.queryType
      }>(schema.${
        this.codegen.schema.queryType
      }, fetchQuery)\n\n      export const query = client.query\n    `
    )
  }
}
class u extends s {
  constructor() {
    super('index')
  }
  generate() {
    return `\n      ${super.generate()}\n\n      export * from './generated'\n      export * from './client'\n    `
  }
}
const h = String.raw,
  l = (e, n = !0) =>
    e
      ? 'NON_NULL' === e.kind
        ? l(e.ofType, !1)
        : {
            kind: e.kind,
            nullable: n,
            ...('LIST' === e.kind ? { ofType: l(e.ofType) } : { name: e.name }),
          }
      : null,
  y = e => {
    const n = {}
    for (const t of e) {
      let e = void 0
      t.args.length &&
        ((e = {}),
        t.args.forEach(n => {
          e[n.name] = l(n.type)
        })),
        (n[t.name] = {
          name: t.name,
          deprecationReason: t.deprecationReason,
          description: t.description,
          isDeprecated: t.isDeprecated,
          args: e,
          type: l(t.type),
        })
    }
    return n
  },
  d = e => {
    const n = {}
    for (const t of e) n[t.name] = { name: t.name, type: l(t.type) }
    return n
  },
  g = e => e.map(e => e.name),
  $ = e => e.map(e => e.name)
;(exports.Codegen = class {
  constructor(e, n) {
    ;(this.schema = e),
      (this.options = { typescript: !0, ...n }),
      (this.files = [
        new m(this),
        new u(),
        new a(this),
        new c(this),
        new o(this),
        new p(),
      ])
  }
  getSchemaType(e) {
    return this.schema.types[e]
  }
  generate() {
    return this.files.map(e => ({
      path: `${e.path}.${this.options.typescript ? 'ts' : 'js'}`,
      overwrite: e.overwrite,
      contents: e.generate(),
    }))
  }
}),
  (exports.fetchSchema = function(e, { includeInfo: n } = {}) {
    try {
      return Promise.resolve(
        e(
          ((e = !1) => h`
  query IntrospectionQuery {
    __schema {
      queryType {
        name
      }
      mutationType {
        name
      }
      types {
        ...FullType
      }
    }
  }

  fragment FullType on __Type {
    kind
    name
    fields(includeDeprecated: true) {
      ${
        e
          ? '\n      description\n      isDeprecated\n      deprecationReason\n      '
          : ''
      }
      name
      args {
        type {
          ...TypeRef
        }
        ...InputValue
      }
      type {
        ...TypeRef
      }
    }
    enumValues {
      name
    }
    inputFields {
      type {
        ...TypeRef
      }
      ...InputValue
    }
    interfaces {
      ...TypeRef
    }
    possibleTypes {
      ...TypeRef
    }
  }

  fragment InputValue on __InputValue {
    name
  }

  fragment TypeRef on __Type {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  }
`)(n)
        )
      ).then(function({ data: e }) {
        return (e => {
          const n = {
            queryType: e.queryType.name,
            mutationType: e.mutationType && e.mutationType.name,
            types: {},
          }
          for (const t of e.types)
            n.types[t.name] = {
              name: t.name,
              kind: t.kind,
              ...('UNION' === t.kind
                ? { possibleTypes: t.possibleTypes.map(({ name: e }) => e) }
                : 'INTERFACE' === t.kind
                ? {
                    possibleTypes: t.possibleTypes.map(({ name: e }) => e),
                    fields: y(t.fields),
                  }
                : 'OBJECT' === t.kind
                ? { fields: y(t.fields), interfaces: g(t.interfaces) }
                : 'INPUT_OBJECT' === t.kind
                ? { inputFields: d(t.inputFields) }
                : 'ENUM' === t.kind
                ? { enumValues: $(t.enumValues) }
                : null),
            }
          return n
        })(e.__schema)
      })
    } catch (e) {
      return Promise.reject(e)
    }
  })
//# sourceMappingURL=schema.cjs.production.min.js.map
