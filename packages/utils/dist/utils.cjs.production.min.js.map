{"version":3,"file":"utils.cjs.production.min.js","sources":["../src/createEvent.ts","../src/invariant.ts","../src/memo.ts","../src/computed.ts","../src/lazyGetters.ts","../src/warning.ts"],"sourcesContent":["export const createEvent = <TCallback extends (...args: any[]) => any>() => {\n  return new Event()\n}\n\nexport class Event<TCallback extends (...args: any[]) => any> {\n  listeners = new Set<TCallback>()\n\n  listen(callback: TCallback) {\n    this.listeners.add(callback)\n    return () => this.off(callback)\n  }\n\n  filter(filter: (...parameters: Parameters<TCallback>) => boolean) {\n    const filteredEvent = createEvent<TCallback>()\n\n    this.listen(((...args: Parameters<TCallback>) => {\n      const shouldEmit = filter(...args)\n      if (!shouldEmit) return\n\n      return filteredEvent.emit(...args)\n    }) as TCallback)\n    return filteredEvent\n  }\n\n  then(callback: TCallback) {\n    const listener = ((...args: any[]) => {\n      this.off(listener)\n\n      return callback(...args)\n    }) as TCallback\n\n    return this.listen(listener)\n  }\n\n  off(callback: TCallback) {\n    this.listeners.delete(callback)\n  }\n\n  emit = (...args: Parameters<TCallback>) => {\n    for (const emit of Array.from(this.listeners)) {\n      emit(...args)\n    }\n  }\n}\n","const isProduction: boolean = process.env.NODE_ENV === 'production'\n\nconst prefix = `[gqless] `\n\nexport function invariant(condition: any, message?: string): asserts condition {\n  if (condition) return\n\n  if (isProduction) {\n    throw new Error(\n      prefix +\n        'invariant exception occured! view full message in development mode'\n    )\n  } else {\n    throw new Error(prefix + message)\n  }\n}\n","type Dependency = {\n  weak: WeakMap<any, Dependency>\n  strong: Map<any, Dependency>\n  value?: any\n}\nconst createDependency = (): Dependency => ({\n  weak: new WeakMap(),\n  strong: new Map(),\n})\n\nconst dependencyType = (data: any) =>\n  data && data instanceof Object ? 'weak' : 'strong'\n\n/**\n * Memory-leak free memoization\n */\nexport function createMemo() {\n  const cache: Map<string, Dependency> = new Map()\n\n  const memoKey = (key = 'default') => {\n    if (!cache.has(key)) cache.set(key, createDependency())\n\n    const keyDependency = cache.get(key)!\n\n    /**\n     * Returns the value for the given dependencies,\n     * otherwise undefined\n     */\n    function memo<T = any>(dependencies: any[]): T | undefined\n    /**\n     * Returns the value for the given dependencies,\n     * otherwise function is called and added to cache\n     */\n    function memo<T>(get: () => T, dependencies?: any[]): T\n\n    function memo<T>(\n      getOrDependencies: any[] | (() => T),\n      dependencies: any[] = []\n    ): T | void {\n      const get =\n        typeof getOrDependencies === 'function' ? getOrDependencies : undefined\n      if (!get) dependencies = getOrDependencies as any[]\n\n      let dependency = keyDependency\n      let index = 0\n      const changedDependency = dependencies.find((data, i) => {\n        index = i\n        const type = dependencyType(data)\n        if (!dependency[type].has(data)) return true\n        dependency = dependency[type].get(data)!\n\n        return false\n      })\n\n      if (!changedDependency && 'value' in dependency) return dependency.value\n\n      if (!get) return\n\n      for (let i = index; i < dependencies.length; i++) {\n        const data = dependencies[i]\n        const newDependency = createDependency()\n        dependency[dependencyType(data)].set(data, newDependency)\n        dependency = newDependency\n      }\n\n      const value = get()\n      dependency.value = value\n      return value\n    }\n\n    return memo\n  }\n\n  return new Proxy(memoKey(), {\n    get(_, prop: any) {\n      return memoKey(prop)\n    },\n  }) as ReturnType<typeof memoKey> & Record<string, ReturnType<typeof memoKey>>\n}\n","export const computed = <T>(\n  target: T,\n  propertyKey: string,\n  descriptor: PropertyDescriptor\n) => {\n  const getValue = descriptor.get\n\n  descriptor.get = function(this: any) {\n    const value = getValue?.call(this)\n    Object.defineProperty(this, propertyKey, {\n      enumerable: true,\n      value,\n    })\n    return value\n  }\n}\n","export const lazyGetters = <T extends Record<any, any>>(\n  obj: T,\n  onEvaluated?: (key: keyof T, value: T[keyof T]) => void\n): T => {\n  for (const key in obj) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key)\n    if (!descriptor) continue\n    const prevGet = descriptor.get\n\n    if (!prevGet) {\n      onEvaluated?.(key, obj[key])\n      continue\n    }\n\n    if (!descriptor.configurable) continue\n\n    Object.defineProperty(obj, key, {\n      ...descriptor,\n      get() {\n        const value = prevGet()\n        Object.defineProperty(obj, key, {\n          configurable: true,\n          writable: false,\n          enumerable: true,\n          value,\n        })\n\n        onEvaluated?.(key, value)\n        return value\n      },\n    })\n  }\n\n  return obj\n}\n","const isProduction: boolean = process.env.NODE_ENV === 'production'\n\nconst prefix = `[gqless] `\n\nexport function warning(condition: any, message?: string) {\n  if (condition) return\n  if (isProduction) return\n\n  const text = prefix + message\n\n  if (typeof console !== 'undefined') {\n    console.warn(text)\n  }\n\n  // Throwing an error and catching it immediately\n  // to improve debugging\n  // A consumer can use 'pause on caught exceptions'\n  // https://github.com/facebook/react/issues/4216\n  try {\n    throw Error(text)\n  } catch (x) {}\n}\n"],"names":["createEvent","Event","constructor","Set","args","emit","Array","from","this","listeners","listen","callback","add","off","filter","filteredEvent","then","listener","delete","createDependency","weak","WeakMap","strong","Map","dependencyType","data","Object","target","propertyKey","descriptor","getValue","get","value","call","defineProperty","enumerable","cache","memoKey","key","has","set","keyDependency","getOrDependencies","dependencies","undefined","dependency","index","find","i","type","length","newDependency","Proxy","_","prop","condition","message","Error","prefix","obj","onEvaluated","getOwnPropertyDescriptor","prevGet","configurable","writable"],"mappings":"0EAAaA,EAAc,IAClB,IAAIC,EAGb,MAAaA,EAAbC,6BACc,IAAIC,cAiCT,IAAIC,SACJ,MAAMC,KAAQC,MAAMC,KAAKC,KAAKC,WACjCJ,KAAQD,IAjCZM,OAAOC,eACAF,UAAUG,IAAID,GACZ,IAAMH,KAAKK,IAAIF,GAGxBG,OAAOA,SACCC,EAAgBf,gBAEjBU,OAAQ,IAAIN,QACIU,KAAUV,UAGtBW,EAAcV,QAAQD,KAExBW,EAGTC,KAAKL,SACGM,EAAY,IAAIb,UACfS,IAAII,GAEFN,KAAYP,WAGdI,KAAKE,OAAOO,GAGrBJ,IAAIF,QACGF,UAAUS,OAAOP,ICjC1B,MCGMQ,EAAmB,MACvBC,KAAM,IAAIC,QACVC,OAAQ,IAAIC,MAGRC,EAAkBC,GACtBA,GAAQA,aAAgBC,OAAS,OAAS,0CCXpB,CACtBC,EACAC,EACAC,WAEMC,EAAWD,EAAWE,IAE5BF,EAAWE,IAAM,iBACTC,EAAQF,MAAAA,SAAAA,EAAUG,KAAKzB,aAC7BkB,OAAOQ,eAAe1B,KAAMoB,EAAa,CACvCO,YAAY,EACZH,MAAAA,IAEKA,6CDGX,iBACQI,EAAiC,IAAIb,IAErCc,EAAU,CAACC,EAAM,aAChBF,EAAMG,IAAID,IAAMF,EAAMI,IAAIF,EAAKnB,WAE9BsB,EAAgBL,EAAML,IAAIO,mBAc9BI,EACAC,EAAsB,UAEhBZ,EACyB,mBAAtBW,EAAmCA,OAAoBE,EAC3Db,IAAKY,EAAeD,OAErBG,EAAaJ,EACbK,EAAQ,MACcH,EAAaI,KAAK,CAACtB,EAAMuB,KACjDF,EAAQE,QACFC,EAAOzB,EAAeC,UACvBoB,EAAWI,GAAMV,IAAId,KAC1BoB,EAAaA,EAAWI,GAAMlB,IAAIN,IAE3B,MAGiB,UAAWoB,EAAY,OAAOA,EAAWb,UAE9DD,EAAK,WAEL,IAAIiB,EAAIF,EAAOE,EAAIL,EAAaO,OAAQF,IAAK,OAC1CvB,EAAOkB,EAAaK,GACpBG,EAAgBhC,IACtB0B,EAAWrB,EAAeC,IAAOe,IAAIf,EAAM0B,GAC3CN,EAAaM,QAGTnB,EAAQD,WACdc,EAAWb,MAAQA,EACZA,WAMJ,IAAIoB,MAAMf,IAAW,CAC1BN,IAAG,CAACsB,EAAGC,IACEjB,EAAQiB,iCDvEKC,EAAgBC,OACpCD,QAGI,IAAIE,MACRC,oGGTqB,CACzBC,EACAC,SAEK,MAAMtB,KAAOqB,EAAK,OACf9B,EAAaH,OAAOmC,yBAAyBF,EAAKrB,OACnDT,EAAY,eACXiC,EAAUjC,EAAWE,IAEtB+B,EAKAjC,EAAWkC,cAEhBrC,OAAOQ,eAAeyB,EAAKrB,EAAK,IAC3BT,EACHE,YACQC,EAAQ8B,WACdpC,OAAOQ,eAAeyB,EAAKrB,EAAK,CAC9ByB,cAAc,EACdC,UAAU,EACV7B,YAAY,EACZH,MAAAA,IAGF4B,MAAAA,GAAAA,EAActB,EAAKN,GACZA,KAlBT4B,MAAAA,GAAAA,EAActB,EAAKqB,EAAIrB,WAuBpBqB,4BC7BeJ,EAAgBC"}