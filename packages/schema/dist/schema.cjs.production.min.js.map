{"version":3,"file":"schema.cjs.production.min.js","sources":["../src/Codegen/File.ts","../src/Codegen/files/generated/schema.ts","../src/Codegen/files/generated/types.ts","../src/Codegen/files/generated/index.ts","../src/Codegen/files/extensions.ts","../src/Codegen/files/client.ts","../src/Codegen/files/index.ts","../src/fetchSchema/introspectionQuery.ts","../src/fetchSchema/introspectionToSchema.ts","../src/Codegen/Codegen.ts","../src/fetchSchema/fetchSchema.ts"],"sourcesContent":["export const CORE = 'gqless'\nexport const UTILS = '@gqless/utils'\n\nexport abstract class File {\n  constructor(public path: string, public overwrite: boolean = true) {}\n\n  private imports = new Map<string, Set<string>>()\n  private importAlls = new Map<string, string>()\n\n  protected import(from: string, ...imports: string[]) {\n    if (!this.imports.has(from)) this.imports.set(from, new Set())\n    const importsSet = this.imports.get(from)!\n    imports.forEach(imp => importsSet.add(imp))\n  }\n\n  protected importAll(from: string, as: string) {\n    if (this.importAlls.has(from)) {\n      const existingName = this.importAlls.get(from)\n      if (existingName !== as)\n        throw new Error(\n          `Already imported all from ${from}, use ${existingName} instead of ${as}`\n        )\n\n      return\n    }\n\n    this.importAlls.set(from, as)\n  }\n\n  public generate() {\n    return [\n      ...Array.from(this.importAlls.entries()).map(\n        ([from, as]) => `import * as ${as} from '${from}'`\n      ),\n      ...Array.from(this.imports.entries()).map(([from, imports]) =>\n        imports.size\n          ? `import { ${Array.from(imports).join(',')} } from '${from}'`\n          : ''\n      ),\n    ].join('\\n')\n  }\n}\n","import { SchemaType, Type, SchemaFieldArgs, SchemaField } from '../../../Schema'\nimport {\n  ObjectNode,\n  ArrayNode,\n  ScalarNode,\n  InputNode,\n  InputNodeField,\n  InterfaceNode,\n  UnionNode,\n  Arguments,\n  ArgumentsField,\n  FieldNode,\n  EnumNode,\n} from 'gqless'\nimport { File, UTILS, CORE } from '../../File'\nimport { Codegen } from '../../Codegen'\n\nexport const SCHEMA_VAR = 'schema'\n\nexport class SchemaFile extends File {\n  constructor(private codegen: Codegen) {\n    super('generated/schema')\n  }\n\n  public generate() {\n    this.importAll(`../extensions`, 'extensions')\n    this.import(UTILS, 'lazyGetters')\n\n    const body = `\n      export const ${SCHEMA_VAR} = ${this.generateSchema()}\n\n      lazyGetters(${SCHEMA_VAR})\n    `\n\n    return `\n      // @ts-nocheck\n      ${super.generate()}\n\n      ${body}\n    `\n  }\n\n  private generateSchema() {\n    return `{\n      ${Object.values(this.codegen.schema.types)\n        .map(\n          type => `get ${type.name}() {\n            return ${this.generateNode(type)}\n          }`\n        )\n        .join(',')}\n    }`\n  }\n\n  private getNode(name: string) {\n    return `${SCHEMA_VAR}.${name}`\n  }\n\n  private getExtension(name: string) {\n    if (this.codegen.options.typescript) {\n      return `(extensions as any || {}).${name}`\n    }\n\n    // || {} is used to confuse webpack which displays errors if you don't export an extension\n    return `(extensions || {}).${name}`\n  }\n\n  private generateFieldGetter(field: SchemaField) {\n    this.import(CORE, FieldNode.name)\n\n    return `get ${field.name}() {\n      return new ${FieldNode.name}(${this.generateType(\n      field.type\n    )}, ${this.generateArguments(field.args)}, ${field.type.nullable})\n    }`\n  }\n\n  private generateNode(type: SchemaType) {\n    switch (type.kind) {\n      case 'OBJECT': {\n        this.import(CORE, ObjectNode.name)\n\n        return `new ${ObjectNode.name}({\n          ${Object.values(type.fields)\n            .map(field => this.generateFieldGetter(field))\n            .join(',')}\n        }, { name: ${JSON.stringify(type.name)}, extension: ${this.getExtension(\n          type.name\n        )} })`\n      }\n\n      case 'INTERFACE': {\n        this.import(CORE, InterfaceNode.name)\n\n        return `new ${InterfaceNode.name}({\n          ${Object.values(type.fields)\n            .map(field => this.generateFieldGetter(field))\n            .join(',')}\n        },\n        [${type.possibleTypes.map(type => this.getNode(type)).join(',')}],\n        { name: ${JSON.stringify(type.name)}, extension: ${this.getExtension(\n          type.name\n        )} })`\n      }\n\n      case 'UNION': {\n        this.import(CORE, UnionNode.name)\n\n        return `new ${UnionNode.name}([${type.possibleTypes.map(type =>\n          this.getNode(type)\n        )}])`\n      }\n\n      case 'SCALAR': {\n        this.import(CORE, ScalarNode.name)\n\n        return `new ${ScalarNode.name}({ name: ${JSON.stringify(\n          type.name\n        )}, extension: ${this.getExtension(type.name)} })`\n      }\n\n      case 'INPUT_OBJECT': {\n        this.import(CORE, InputNode.name)\n\n        return `new ${InputNode.name}({\n          ${Object.values(type.inputFields)\n            .map(field => {\n              this.import(CORE, InputNodeField.name)\n\n              return `get ${field.name}() {\n                return new ${InputNodeField.name}(${this.generateType(\n                field.type\n              )}, ${field.type.nullable})\n              }`\n            })\n            .join(',')}\n        }, ${JSON.stringify({ name: type.name })})`\n      }\n\n      case 'ENUM': {\n        this.import(CORE, EnumNode.name)\n\n        return `new ${EnumNode.name}({ name: ${JSON.stringify(type.name)} })`\n      }\n    }\n\n    return undefined\n  }\n\n  private generateType(type: Type): string {\n    this.import(CORE, ArrayNode.name)\n\n    if (type.kind === 'LIST') {\n      return `new ${ArrayNode.name}(${this.generateType(type.ofType)}, ${\n        type.nullable\n      })`\n    }\n\n    return this.getNode(type.name)\n  }\n\n  public generateArguments(args?: SchemaFieldArgs) {\n    if (!args) return undefined\n\n    this.import(CORE, Arguments.name)\n\n    const argsRequired = !Object.values(args).find(arg => arg.nullable)\n      ? ', true'\n      : ''\n\n    return `new ${Arguments.name}({\n      ${Object.entries(args)\n        .map(([name, type]) => {\n          this.import(CORE, ArgumentsField.name)\n\n          return `get ${name}() {\n            return new ${ArgumentsField.name}(${this.generateType(type)}, ${\n            type.nullable\n          })}`\n        })\n        .join(',')}\n    }${argsRequired})`\n  }\n}\n","import { File, CORE } from '../../File'\nimport { Codegen } from '../../Codegen'\nimport {\n  SchemaType,\n  SchemaField,\n  Type,\n  SchemaInterfaceType,\n  SchemaFieldArgs,\n  SchemaEnumType,\n} from '../../../Schema'\n\nconst TYPE_PREFIX = 't_'\n\ntype TypeResolver = (name: string) => string\n\nexport class TypesFile extends File {\n  constructor(private codegen: Codegen) {\n    super('generated/types')\n  }\n\n  private createUniqueNames<TName extends string>(\n    reservedNames: string[],\n    names: TName[],\n    makeUnique: (name: string) => string\n  ) {\n    const namesObj = {} as Record<TName, string>\n\n    const uniqueName = (desiredName: string): string => {\n      if (reservedNames.includes(desiredName))\n        return uniqueName(makeUnique(desiredName))\n\n      return desiredName\n    }\n\n    for (const name of names) {\n      const chosenName = uniqueName(name)\n      reservedNames.push(chosenName)\n\n      namesObj[name] = chosenName\n    }\n\n    return namesObj\n  }\n\n  private typeNames = this.createUniqueNames(\n    Object.keys(this.codegen.schema.types),\n    Object.keys(this.codegen.schema.types),\n    name => {\n      return `${TYPE_PREFIX}${name}`\n    }\n  )\n\n  private names = this.createUniqueNames(\n    [\n      ...Object.keys(this.codegen.schema.types),\n      ...Object.values(this.typeNames),\n    ],\n    [\n      'Extension',\n      'EnumType',\n      'FieldsType',\n      'FieldsTypeArg',\n      'ScalarType',\n      'TypeData',\n      'extensions',\n    ],\n    name => `gqless_${name}`\n  )\n\n  private typeReference = (name: string): string => {\n    const schemaType = this.codegen.getSchemaType(name)\n\n    if (schemaType.kind === 'INPUT_OBJECT') return name\n\n    return this.typeNames[name]\n  }\n\n  private typeValue = (name: string) => {\n    const type = this.codegen.getSchemaType(name)\n\n    if (type.kind === 'SCALAR') {\n      return this.defaultScalarType(type)\n    }\n\n    return type.name\n  }\n\n  public generate() {\n    this.import(CORE, this.names.TypeData)\n    this.importAll('../extensions', this.names.extensions)\n\n    const body = Object.values(this.codegen.schema.types)\n      .map(type => {\n        const definition = this.generateSchemaType(type)\n        if (!definition) return\n\n        return this.generateComments(this.schemaTypeComments(type)) + definition\n      })\n      .filter(Boolean)\n      .join('\\n\\n')\n\n    return `\n      ${super.generate()}\n\n      type ${\n        this.names.Extension\n      }<TName extends string> = TName extends keyof typeof ${\n      this.names.extensions\n    }\n        ? typeof ${this.names.extensions}[TName]\n        : any\n\n      ${body}\n\n      ${Object.values(this.codegen.schema.types)\n        .filter(type => type.kind !== 'INPUT_OBJECT')\n        .map(type =>\n          type.kind === 'ENUM'\n            ? `${this.generateComments(\n                this.schemaTypeComments(type)\n              )}export enum ${type.name} { \\n\n          ${(type as SchemaEnumType).enumValues.map(k => `${k} = '${k}' \\n`)}\n          }`\n            : `${this.generateComments(\n                this.schemaTypeComments(type)\n              )}export type ${type.name} = ${\n                this.names.TypeData\n              }<${this.typeReference(type.name)}>`\n        )\n        .join('\\n')}\n    `\n  }\n\n  private schemaTypeComments(type: SchemaType) {\n    const comments: string[] = [`@name ${type.name}`, `@type ${type.kind}`]\n\n    if (type.kind === 'OBJECT' && type.interfaces.length) {\n      comments.push(`@implements ${type.interfaces.join(', ')}`)\n    }\n\n    return comments\n  }\n\n  private generateComments(comments: string[]) {\n    if (comments.length)\n      return (\n        `\\n` +\n        `/**\\n` +\n        ` * ${comments.join('\\n* ').replace(/\\*\\//gm, '*\\u200B/')}\\n` +\n        ` */\\n`\n      )\n\n    return ''\n  }\n\n  private generateFieldComments(field: SchemaField) {\n    const comments: string[] = []\n    if (field.isDeprecated) {\n      comments.push(\n        `@deprecated${\n          field.deprecationReason\n            ? ` ${field.deprecationReason.replace(/\\n/gm, ' ')}`\n            : ''\n        }`\n      )\n    }\n\n    if (field.description) {\n      comments.push(...field.description.split('\\n'))\n    }\n\n    return this.generateComments(comments)\n  }\n\n  public generateSchemaType(type: SchemaType): string | undefined {\n    switch (type.kind) {\n      case 'SCALAR':\n        return this.generateScalarType(type)\n\n      case 'UNION':\n      case 'INTERFACE':\n        return `type ${this.typeReference(\n          type.name\n        )} = ${type.possibleTypes\n          .map(name => this.typeReference(name))\n          .join(' | ')}`\n\n      case 'OBJECT': {\n        this.import(CORE, this.names.FieldsType)\n\n        return `type ${this.typeReference(type.name)} = ${\n          this.names.FieldsType\n        }<{\\n${[\n          `__typename: ${this.typeReference('String')}<'${type.name}'>`,\n          ...Object.values(type.fields).map(field => this.generateField(field)),\n        ].join('\\n')}\\n}, ${this.names.Extension}<'${type.name}'>>`\n      }\n\n      case 'INPUT_OBJECT':\n        return `export type ${this.typeReference(type.name)} = {${Object.values(\n          type.inputFields\n        )\n          .map(field => this.generateField(field, this.typeValue))\n          .join('\\n')}}`\n\n      case 'ENUM': {\n        this.import(CORE, this.names.EnumType)\n\n        return `type ${this.typeReference(type.name)} = ${\n          this.names.EnumType\n        }<${type.enumValues.map(value => `'${value}'`).join(' | ')}>`\n      }\n\n      default:\n        return\n    }\n  }\n\n  public generateArgs(args: SchemaFieldArgs) {\n    return `{${Object.entries(args)\n      .map(([name, type]) => {\n        const NULLABLE = type.nullable ? '?' : ''\n\n        return `${name}${NULLABLE}: ${this.generateType(type, this.typeValue)}`\n      })\n      .join(',')}}`\n  }\n\n  public generateField(field: SchemaField, resolveType?: TypeResolver) {\n    const NULLABLE = field.type.nullable ? '?' : ''\n    const fieldType = this.generateType(field.type, resolveType)\n\n    if (field.args) this.import(CORE, this.names.FieldsTypeArg)\n\n    return `${this.generateFieldComments(field)}${field.name} ${\n      field.args\n        ? `: ${this.names.FieldsTypeArg}<${this.generateArgs(\n            field.args\n          )}, ${fieldType}>`\n        : `${NULLABLE}: ${fieldType}`\n    }`\n  }\n\n  public generateType(type: Type, resolveType = this.typeReference): string {\n    const nullType = type.nullable ? '| null' : ''\n\n    switch (type.kind) {\n      case 'OBJECT':\n      case 'ENUM':\n      case 'INPUT_OBJECT':\n      case 'UNION':\n      case 'INTERFACE':\n      case 'SCALAR':\n        return `${resolveType(type.name)}${nullType}`\n\n      case 'LIST':\n        return `(${this.generateType(type.ofType, resolveType)})[]${nullType}`\n\n      default:\n        return 'any'\n    }\n  }\n\n  public defaultScalarType(scalar: SchemaType) {\n    switch (scalar.name) {\n      case 'ID':\n      case 'String':\n      case 'Date':\n      case 'URI':\n        return `string`\n\n      case 'Int':\n      case 'Float':\n        return `number`\n\n      case 'Boolean':\n        return `boolean`\n\n      case 'JSON':\n        return `{ [K: string]: any }`\n    }\n    return 'any'\n  }\n\n  public generateScalarType(scalar: SchemaType) {\n    this.import(CORE, this.names.ScalarType)\n\n    const type = this.defaultScalarType(scalar)\n\n    return `type ${this.typeReference(\n      scalar.name\n    )}<T extends ${type} = ${type}> = ${this.names.ScalarType}<T, ${\n      this.names.Extension\n    }<'${scalar.name}'>>`\n  }\n}\n","import { File } from '../../File'\n\nexport class IndexFile extends File {\n  constructor() {\n    super('generated/index')\n  }\n\n  public generate() {\n    return `\n      ${super.generate()}\n\n      export * from './schema'\n      export * from './types'\n    `\n  }\n}\n\nexport * from './schema'\nexport * from './types'\n","import { File } from '../File'\nimport { Codegen } from '../Codegen'\n\nexport class ExtensionsFile extends File {\n  constructor(private codegen: Codegen) {\n    super('extensions/index', false)\n  }\n\n  public generate() {\n    // TODO: default keys\n\n    return `\n      ${super.generate()}\n\n      export const Query = {}\n\n      /**\n       * Add a key to a type\n       */\n      // export const User = {\n      //   [GET_KEY]: (user) => user.id\n      // }\n\n      /**\n       * Add custom data to a type\n       * @example\n       * query.users[0].follow()\n       */\n      // export const User = (user) => ({\n      //   follow() {\n      //     console.log('follow', user.id)\n      //   }\n      // })\n    `\n  }\n}\n","import { File, CORE } from '../File'\nimport { Codegen } from '../Codegen'\n\nexport class ClientFile extends File {\n  constructor(private codegen: Codegen) {\n    super('client', false)\n  }\n\n  public generate() {\n    this.import(CORE, 'Client', 'QueryFetcher')\n    this.import('./generated', 'schema', this.codegen.schema.queryType)\n\n    return `\n      ${super.generate()}\n\n      const endpoint = ${JSON.stringify(this.codegen.options.url || '')}\n\n      const fetchQuery: QueryFetcher = async (query, variables) => {\n        const response = await fetch(endpoint, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',${\n              this.codegen.options.headers ? Object.entries(this.codegen.options.headers).map(\n                ([key, value]) => `'${key}': '${value}'`\n              ).join('\\n') : ''\n            }\n          },\n          body: JSON.stringify({\n            query,\n            variables,\n          }),\n          mode: 'cors',\n        })\n\n        if (!response.ok) {\n          throw new Error(\\`Network error, received status code $\\{response.status}\\`)\n        }\n\n        const json = await response.json()\n\n        return json\n      }\n\n      export const client = new Client<${\n        this.codegen.schema.queryType\n      }>(schema.${this.codegen.schema.queryType}, fetchQuery)\n\n      export const query = client.query\n    `\n  }\n}\n","import * as generated from './generated'\nimport { File } from '../File'\n\nexport class IndexFile extends File {\n  constructor() {\n    super('index')\n  }\n\n  public generate() {\n    return `\n      ${super.generate()}\n\n      export * from './generated'\n      export * from './client'\n    `\n  }\n}\n\nexport * from './extensions'\nexport * from './client'\n\nexport { generated }\n","const gql = String.raw\n\nexport const introspectionQuery = (includeInfo = false) => gql`\n  query IntrospectionQuery {\n    __schema {\n      queryType {\n        name\n      }\n      mutationType {\n        name\n      }\n      types {\n        ...FullType\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    fields(includeDeprecated: true) {\n      ${\n        includeInfo\n          ? `\n      description\n      isDeprecated\n      deprecationReason\n      `\n          : ''\n      }\n      name\n      args {\n        type {\n          ...TypeRef\n        }\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n    }\n    enumValues {\n      name\n    }\n    inputFields {\n      type {\n        ...TypeRef\n      }\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`\n","import {\n  Schema,\n  Type,\n  SchemaFields,\n  SchemaInputFields,\n  SchemaFieldArgs,\n} from '../Schema'\n\nconst getType = (type: any, nullable = true): Type | null => {\n  if (!type) return null\n  if (type.kind === 'NON_NULL') return getType(type.ofType, false)\n\n  return {\n    kind: type.kind,\n    nullable,\n    ...(type.kind === 'LIST'\n      ? { ofType: getType(type.ofType)! }\n      : { name: type.name }),\n  }\n}\n\nconst getFields = (introspectionFields: any) => {\n  const fields: SchemaFields = {}\n\n  for (const field of introspectionFields) {\n    let args: SchemaFieldArgs | undefined = undefined\n    if (field.args.length) {\n      args = {}\n      field.args.forEach((arg: any) => {\n        args![arg.name as string] = getType(arg.type)!\n      })\n    }\n\n    fields[field.name] = {\n      name: field.name,\n      deprecationReason: field.deprecationReason,\n      description: field.description,\n      isDeprecated: field.isDeprecated,\n      args,\n      type: getType(field.type)!,\n    }\n  }\n\n  return fields\n}\n\nconst getInputObjectFields = (introspectionFields: any) => {\n  const fields: SchemaInputFields = {}\n\n  for (const field of introspectionFields) {\n    fields[field.name] = {\n      name: field.name,\n      type: getType(field.type)!,\n    }\n  }\n\n  return fields\n}\n\nconst getInterfaces = (interfaces: any) =>\n  interfaces.map((_interface: any) => _interface.name)\n\nconst getEnumValues = (enumValues: any) =>\n  enumValues.map((enumValues: any) => enumValues.name)\n\nexport const introspectionToSchema = (introspection: any) => {\n  const schema: Schema = {\n    queryType: introspection.queryType.name,\n    mutationType: introspection.mutationType && introspection.mutationType.name,\n    types: {},\n  }\n\n  for (const type of introspection.types) {\n    schema.types[type.name] = {\n      name: type.name,\n      kind: type.kind,\n      ...(type.kind === 'UNION'\n        ? { possibleTypes: type.possibleTypes.map(({ name }: any) => name) }\n        : type.kind === 'INTERFACE'\n        ? {\n            possibleTypes: type.possibleTypes.map(({ name }: any) => name),\n            fields: getFields(type.fields),\n          }\n        : type.kind === 'OBJECT'\n        ? {\n            fields: getFields(type.fields),\n            interfaces: getInterfaces(type.interfaces),\n          }\n        : type.kind === 'INPUT_OBJECT'\n        ? {\n            inputFields: getInputObjectFields(type.inputFields),\n          }\n        : type.kind === 'ENUM'\n        ? { enumValues: getEnumValues(type.enumValues) }\n        : null),\n    }\n  }\n\n  return schema\n}\n","import { Schema } from '../Schema'\nimport * as graphql from './files'\nimport { File } from './File'\n\ninterface CodegenOptions {\n  url?: string\n  typescript?: boolean\n  headers?: Record<string, string>\n}\n\nexport class Codegen {\n  public options: CodegenOptions\n  public files: File[]\n\n  constructor(public schema: Schema, options?: CodegenOptions) {\n    this.options = {\n      typescript: true,\n      ...options,\n    }\n\n    this.files = [\n      new graphql.ExtensionsFile(this),\n      new graphql.IndexFile(),\n\n      new graphql.generated.SchemaFile(this),\n      new graphql.ClientFile(this),\n      new graphql.generated.TypesFile(this),\n      new graphql.generated.IndexFile(),\n    ]\n  }\n\n  public getSchemaType(name: string) {\n    return this.schema.types[name]\n  }\n\n  public generate() {\n    return this.files.map(file => ({\n      path: `${file.path}.${this.options.typescript ? 'ts' : 'js'}`,\n      overwrite: file.overwrite,\n      contents: file.generate(),\n    }))\n  }\n}\n","import { introspectionQuery } from './introspectionQuery'\nimport { introspectionToSchema } from './introspectionToSchema'\nimport { QueryFetcher } from 'gqless'\n\nexport type IFetchSchemaOptions = {\n  includeInfo?: boolean\n}\n\nexport const fetchSchema = async (\n  fetchQuery: QueryFetcher,\n  { includeInfo }: IFetchSchemaOptions = {}\n) => {\n  const { data } = await fetchQuery(introspectionQuery(includeInfo))\n\n  return introspectionToSchema(data.__schema)\n}\n"],"names":["CORE","UTILS","File","constructor","path","overwrite","Map","import","from","imports","this","has","set","Set","importsSet","get","forEach","imp","add","importAll","as","importAlls","existingName","Error","generate","Array","entries","map","size","join","SCHEMA_VAR","SchemaFile","codegen","body","generateSchema","super","Object","values","schema","types","type","name","generateNode","getNode","getExtension","options","typescript","generateFieldGetter","field","FieldNode","generateType","generateArguments","args","nullable","kind","ObjectNode","fields","JSON","stringify","InterfaceNode","possibleTypes","UnionNode","ScalarNode","InputNode","inputFields","InputNodeField","EnumNode","ArrayNode","ofType","Arguments","argsRequired","find","arg","ArgumentsField","TYPE_PREFIX","TypesFile","createUniqueNames","keys","typeNames","getSchemaType","defaultScalarType","reservedNames","names","makeUnique","namesObj","uniqueName","desiredName","includes","chosenName","push","TypeData","extensions","definition","generateSchemaType","generateComments","schemaTypeComments","filter","Boolean","Extension","enumValues","k","typeReference","comments","interfaces","length","replace","generateFieldComments","isDeprecated","deprecationReason","description","split","generateScalarType","FieldsType","generateField","typeValue","EnumType","value","generateArgs","resolveType","NULLABLE","fieldType","FieldsTypeArg","nullType","scalar","ScalarType","IndexFile","ExtensionsFile","ClientFile","queryType","url","headers","key","gql","String","raw","getType","getFields","introspectionFields","undefined","getInputObjectFields","getInterfaces","_interface","getEnumValues","files","graphql","file","contents","fetchQuery","includeInfo","introspectionQuery","data","introspection","mutationType","introspectionToSchema","__schema"],"mappings":"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"}