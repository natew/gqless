'use strict'
Object.defineProperty(exports, '__esModule', { value: !0 })
const e = () => new t()
class t {
  constructor() {
    ;(this.listeners = new Set()),
      (this.emit = (...e) => {
        for (const t of Array.from(this.listeners)) t(...e)
      })
  }
  listen(e) {
    return this.listeners.add(e), () => this.off(e)
  }
  filter(t) {
    const n = e()
    return (
      this.listen((...e) => {
        if (t(...e)) return n.emit(...e)
      }),
      n
    )
  }
  then(e) {
    const t = (...n) => (this.off(t), e(...n))
    return this.listen(t)
  }
  off(e) {
    this.listeners.delete(e)
  }
}
const n = () => ({ weak: new WeakMap(), strong: new Map() }),
  r = e => (e && e instanceof Object ? 'weak' : 'strong')
;(exports.Event = t),
  (exports.computed = (e, t, n) => {
    const r = n.get
    n.get = function() {
      const e = null == r ? void 0 : r.call(this)
      return Object.defineProperty(this, t, { enumerable: !0, value: e }), e
    }
  }),
  (exports.createEvent = e),
  (exports.createMemo = function() {
    const e = new Map(),
      t = (t = 'default') => {
        e.has(t) || e.set(t, n())
        const o = e.get(t)
        return function(e, t = []) {
          const s = 'function' == typeof e ? e : void 0
          s || (t = e)
          let i = o,
            c = 0
          if (
            !t.find((e, t) => {
              c = t
              const n = r(e)
              return !i[n].has(e) || ((i = i[n].get(e)), !1)
            }) &&
            'value' in i
          )
            return i.value
          if (!s) return
          for (let e = c; e < t.length; e++) {
            const o = t[e],
              s = n()
            i[r(o)].set(o, s), (i = s)
          }
          const u = s()
          return (i.value = u), u
        }
      }
    return new Proxy(t(), { get: (e, n) => t(n) })
  }),
  (exports.invariant = function(e, t) {
    if (!e)
      throw new Error(
        '[gqless] invariant exception occured! view full message in development mode'
      )
  }),
  (exports.lazyGetters = (e, t) => {
    for (const n in e) {
      const r = Object.getOwnPropertyDescriptor(e, n)
      if (!r) continue
      const o = r.get
      o
        ? r.configurable &&
          Object.defineProperty(e, n, {
            ...r,
            get() {
              const r = o()
              return (
                Object.defineProperty(e, n, {
                  configurable: !0,
                  writable: !1,
                  enumerable: !0,
                  value: r,
                }),
                null == t || t(n, r),
                r
              )
            },
          })
        : null == t || t(n, e[n])
    }
    return e
  }),
  (exports.warning = function(e, t) {})
//# sourceMappingURL=utils.cjs.production.min.js.map
