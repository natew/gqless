{"version":3,"file":"react.cjs.development.js","sources":["../src/hooks/useComponentContext.ts","../src/hooks/useComponentMemo.ts","../src/hooks/useVariable.ts","../src/hooks/usePoll.ts","../src/hooks/useFragment.ts","../src/hooks/useTracked.ts","../src/Query.tsx","../src/hooks/useForceUpdate.ts","../src/graphql/useInterceptor.ts","../src/graphql/useAccessors.ts","../src/graphql/useFragments.ts","../src/graphql/graphql.tsx","../src/ofType/ofType.ts"],"sourcesContent":["import { Query, Accessor, Fragment, ObjectNode, Scheduler } from 'gqless'\nimport { StackContext } from '../Query'\nimport { invariant } from '@gqless/utils'\n\nexport type VariantFragments = Map<Accessor, Set<Fragment>>\nexport type ComponentFragment = WeakMap<ObjectNode, Fragment>\n\nexport interface ComponentContext {\n  query: Query\n  stack: StackContext\n  accessors: Set<Accessor>\n  schedulers: Set<Scheduler>\n\n  // Fragments to be used for render variants\n  variantFragments: VariantFragments\n\n  // Global component state\n  lastStateIndex: number\n  state: any[]\n}\n\n/**\n * Returns the current context, for a component\n * wrapped in `graphql()`\n */\nexport const useComponentContext = () => {\n  invariant(\n    useComponentContext.value,\n    `not called within a wrapped graphql() component's render phase`\n  )\n\n  return useComponentContext.value\n}\n\nuseComponentContext.value = undefined as ComponentContext | undefined\n","import { createMemo } from '@gqless/utils'\nimport { useComponentContext } from './useComponentContext'\n\n/**\n * createMemo, persisted across all instances of Component\n */\nexport const useComponentMemo = <T>(\n  getValue: () => T,\n  dependencies?: any[]\n) => {\n  const context = useComponentContext()\n  const stateIndex = ++context.lastStateIndex\n\n  const memo: ReturnType<typeof createMemo> =\n    context.state[stateIndex] || (context.state[stateIndex] = createMemo())\n\n  return memo(getValue, dependencies)\n}\n","import { Variable } from 'gqless'\nimport { useMemo, useEffect } from 'react'\nimport { useComponentMemo } from './useComponentMemo'\n\nexport function useVariable<TValue>(\n  value: TValue,\n  name?: string\n): Variable<TValue>\n\nexport function useVariable<TValue>(\n  value: TValue,\n  nullable?: boolean,\n  name?: string\n): Variable<TValue>\n\nexport function useVariable(value: any, _1?: any, _2?: any) {\n  const nullable = typeof _1 === 'boolean' ? _1 : undefined\n  const name = _2 !== undefined ? _2 : typeof _1 === 'string' ? _1 : undefined\n\n  // TODO: useMemo\n  const variable = useComponentMemo(\n    () => new Variable(value, { name, nullable }),\n    []\n  )\n\n  useEffect(() => {\n    if (nullable === undefined) return\n\n    variable.updateNullable(nullable)\n  }, [variable, nullable])\n\n  useEffect(() => {\n    variable.updateValue(value)\n  }, [variable, value])\n\n  return variable\n}\n","import { getAccessor, Poller } from 'gqless'\nimport { useEffect, useMemo, useState } from 'react'\nimport { useComponentContext } from './useComponentContext'\n\nexport const usePoll = (\n  data: any,\n  interval: number,\n  initiallyPolling = true\n) => {\n  const accessor = getAccessor(data)\n  const { stack } = useComponentContext()\n  const [isPolling, setIsPolling] = useState(initiallyPolling)\n\n  const poller = useMemo(() => new Poller(accessor, interval, stack.frames), [\n    accessor,\n  ])\n  useEffect(() => () => poller.toggle(false), [accessor])\n\n  useEffect(() => {\n    poller.updateInterval(interval)\n  }, [interval])\n\n  useEffect(() => {\n    poller.toggle(isPolling)\n  }, [poller, isPolling])\n\n  return [\n    isPolling,\n    (poll = !isPolling) => {\n      setIsPolling(poll)\n    },\n  ] as const\n}\n","import {\n  Fragment,\n  getAccessor,\n  NodeContainer,\n  ObjectNode,\n  fragmentOn,\n  FragmentAccessor,\n  getAbstractImplementation,\n} from 'gqless'\nimport { useMemo } from 'react'\nimport { useComponentMemo } from './useComponentMemo'\n\ntype OfType<TData, TTypename> = TData extends { __typename: TTypename }\n  ? TData\n  : never\n\n/**\n * Creates a new fragment (same across all instances of component)\n */\nexport function useFragment<\n  TData extends { __typename: string },\n  TTypename extends TData['__typename'] = never\n>(\n  data: TData,\n  onType?: TTypename,\n  fragmentName?: string\n): OfType<TData, TTypename> extends never ? TData : OfType<TData, TTypename> {\n  let accessor = getAccessor(data)\n\n  if (accessor instanceof FragmentAccessor) {\n    accessor = accessor.parent\n  }\n\n  const node = useMemo(() => {\n    const node =\n      accessor.node instanceof NodeContainer\n        ? accessor.node.innerNode\n        : accessor.node\n\n    if (onType) {\n      const nodeImplementation = getAbstractImplementation(node, onType)\n      if (nodeImplementation) return nodeImplementation\n    }\n\n    return node\n  }, [accessor.node, onType]) as ObjectNode\n\n  const fragment = useComponentMemo(() => new Fragment(node, fragmentName), [\n    node,\n  ])\n\n  useMemo(() => {\n    if (!fragmentName) return\n    fragment.name = fragmentName\n  }, [fragment, fragmentName])\n\n  const fragmentData = useMemo(() => fragmentOn(accessor, fragment), [\n    accessor,\n    fragment,\n  ])\n\n  return fragmentData\n}\n","import { useComponentContext } from './useComponentContext'\n\nexport const useTracked = () => {\n  const { stack, schedulers } = useComponentContext()\n\n  return <T>(callback: () => T): T => {\n    try {\n      schedulers.forEach(s => s.pushStack(...stack.frames))\n      return callback()\n    } finally {\n      schedulers.forEach(s => s.popStack(...stack.frames))\n    }\n  }\n}\n","import * as React from 'react'\nimport { Query as QueryCl } from 'gqless'\n\nexport interface StackContext {\n  frames: QueryCl[]\n  inheritance: boolean\n}\n\nexport const StackContext = React.createContext<StackContext>({\n  frames: [],\n  inheritance: true,\n})\n\ntype QueryFrame = QueryCl | string | undefined\n\nexport const Query: React.SFC<{\n  value?: QueryFrame[] | QueryFrame | null\n  /**\n   * Whether or not child components can use their own queries.\n   *\n   * true  | child components can use their own queries\n   * false | (default) all queries will be merged into this components query\n   * null  | inherited with React context\n   */\n  allowInheritance?: boolean | null\n  children: any\n}> = ({\n  value = null,\n\n  allowInheritance = false,\n  children,\n}) => {\n  const parentStack = React.useContext(StackContext)\n\n  const stack: StackContext = React.useMemo(() => {\n    const frames =\n      value === null\n        ? parentStack.frames\n        : value instanceof QueryCl\n        ? [value]\n        : (Array.isArray(value) ? value : [value]).map(\n            value => new QueryCl(typeof value === 'string' ? value : undefined)\n          )\n\n    return {\n      frames,\n      inheritance:\n        allowInheritance === null ? parentStack.inheritance : allowInheritance,\n    }\n  }, [value, allowInheritance])\n\n  return <StackContext.Provider value={stack}>{children}</StackContext.Provider>\n}\n","import { useState, useRef, useEffect } from 'react'\nimport { afterTransaction } from 'gqless'\n\nexport const useForceUpdate = () => {\n  const [_, setRerenders] = useState(0)\n  const timerRef = useRef<{ rendered: boolean; timer: any; }>()\n  const mountedRef = useRef<boolean>(true)\n\n  useEffect(() => {\n    return () => {\n      clearTimeout(timerRef.current?.timer)\n      mountedRef.current = false\n    }\n  }, [])\n\n  return (callback?: Function) => afterTransaction(() => {\n    if (!mountedRef.current) return\n\n    const setRef = () => {\n      timerRef.current = { rendered: false, timer: setTimeout(() => {\n        timerRef.current = undefined\n      })}\n    }\n\n    if (!timerRef.current) setRef()\n    if (timerRef.current!.rendered) return\n\n    timerRef.current!.rendered = true\n    setRerenders(r => r + 1)\n    callback?.()\n  })\n}\n","import { Accessor, Interceptor, Scheduler } from 'gqless'\nimport { StackContext } from '../Query'\n\nexport const useInterceptor = (stack: StackContext) => {\n  // Create a new Interceptor, which tracks the usage\n  // of accessors\n  const interceptor = new Interceptor()\n\n  // When a new accessor is found, retrieve the\n  // scheduler associated with it\n  //\n  // Then call Scheduler#pushStack, with the\n  // component's stack\n  const schedulers = new Set<Scheduler>()\n  const interceptedAccessors = new Set<Accessor>()\n\n  // @ts-ignore\n  interceptor.onAccessor.listen(accessor => {\n    interceptedAccessors.add(accessor)\n\n    if (schedulers.has(accessor.scheduler)) return\n    schedulers.add(accessor.scheduler)\n\n    accessor.scheduler.pushStack(...stack.frames)\n  })\n\n  return {\n    interceptor,\n    schedulers,\n    interceptedAccessors,\n    startIntercepting() {\n      interceptor.start()\n    },\n    stopIntercepting() {\n      interceptor.stop()\n\n      // Cleanup the previous Scheduler#pushStack\n      // calls made earlier\n      schedulers.forEach(scheduler => {\n        scheduler.popStack(...stack.frames)\n      })\n    },\n  }\n}\n","import { Accessor, NetworkStatus } from 'gqless'\nimport { useMemo, useEffect } from 'react'\nimport { useForceUpdate } from '../hooks/useForceUpdate'\nimport { StackContext } from '../Query'\nimport { useInterceptor } from './useInterceptor'\n\nexport const useAccessors = (stack: StackContext) => {\n  const accessors = useMemo(() => new Set<Accessor>(), [])\n\n  const accessorDisposers = useMemo(() => new Map<Accessor, Function[]>(), [])\n  const forceUpdate = useForceUpdate()\n\n  useEffect(() => {\n    return () => {\n      accessorDisposers.forEach(disposers => {\n        disposers.forEach(dispose => dispose())\n      })\n    }\n  }, [])\n\n  const interceptor = useInterceptor(stack)\n\n  return {\n    ...interceptor,\n    accessors,\n    updateAccessors(): Promise<void> | void {\n      // Find all the new accessors and add to Set\n      interceptor.interceptedAccessors.forEach(accessor => {\n        if (accessors.has(accessor)) return\n\n        accessors.add(accessor)\n        accessorDisposers.set(\n          accessor,\n          // Make component update when data changes\n          [\n            accessor.onDataChange.listen(() => {\n              forceUpdate()\n            }),\n            accessor.onStatusChange.listen((newValue, prevValue) => {\n              const prevIdle = prevValue === NetworkStatus.idle\n              const active = newValue !== NetworkStatus.idle\n\n              if (prevIdle && active) {\n                forceUpdate()\n              }\n            }),\n          ]\n        )\n      })\n\n      const nonIdleAccessors = new Set<Accessor>()\n\n      accessors.forEach(accessor => {\n        // Locate accessors currently being fetched,\n        // and add to Set\n        if (interceptor.interceptedAccessors.has(accessor)) {\n          if (accessor.status === NetworkStatus.loading) {\n            nonIdleAccessors.add(accessor)\n          }\n\n          return\n        }\n\n        // Remove previously used accessors, that\n        // aren't required anymore\n        const disposers = accessorDisposers.get(accessor)\n        if (disposers) {\n          accessorDisposers.delete(accessor)\n          disposers.forEach(dispose => dispose())\n        }\n        accessors.delete(accessor)\n      })\n\n      if (nonIdleAccessors.size) {\n        return new Promise(resolve => {\n          nonIdleAccessors.forEach(accessor => {\n            accessor.onStatusChange.then(() => {\n              nonIdleAccessors.delete(accessor)\n              if (!nonIdleAccessors.size) resolve()\n            })\n          })\n        })\n      }\n    },\n  }\n}\n","import { VariantFragments } from '../hooks/useComponentContext'\nimport { Accessor, Fragment, FragmentAccessor, NetworkStatus } from 'gqless'\nimport { createContext, useContext } from 'react'\n\nexport type Variant = [Accessor, Fragment][]\nexport const VariantContext = createContext<Variant>([])\n\nexport const useFragments = () => {\n  const variant = useContext(VariantContext)\n  const variantFragments: VariantFragments = new Map()\n\n  const stopResolving: Function[] = []\n\n  return {\n    variantFragments,\n    startResolving() {\n      variant.forEach(([accessor, fragment]) => {\n        const fragmentAccessor =\n          accessor.get<FragmentAccessor>(a => a.selection === fragment) ||\n          new FragmentAccessor(accessor, fragment)\n\n        stopResolving.push(fragmentAccessor.startResolving())\n      })\n    },\n    stopResolving() {\n      stopResolving.forEach(stop => stop())\n    },\n    getRenderVariants() {\n      let variants: Variant[] = []\n\n      variantFragments.forEach((fragments, accessor) => {\n        // Only render variations for accessors\n        // without a value and non-idle\n        if (accessor.value || accessor.status === NetworkStatus.idle) return\n\n        if (!variants.length) {\n          fragments.forEach(fragment => variants.push([[accessor, fragment]]))\n          return\n        }\n\n        const newVariants: typeof variants = []\n        fragments.forEach(fragment => {\n          for (let i = 0; i < variants.length; i++) {\n            const variant = variants[i]\n            newVariants.push([...variant, [accessor, fragment]])\n          }\n        })\n        variants = newVariants\n      })\n\n      return variants\n    },\n  }\n}\n","import * as React from 'react'\nimport { Query } from 'gqless'\nimport { useComponentContext } from '../hooks/useComponentContext'\nimport { StackContext } from '../Query'\nimport { useAccessors } from './useAccessors'\nimport { useFragments, VariantContext } from './useFragments'\n\nexport interface IGraphQLOptions {\n  name?: string\n  seperateRequest?: boolean\n  /**\n   * Whether or not child components can use their own queries.\n   *\n   * true  | child components can use their own queries\n   * false | all queries will be merged into this components query\n   * null  | (default) inherited with React context\n   */\n  allowInheritance?: boolean | null\n}\n\nexport const graphql = <Props extends any>(\n  component: (props: Props) => any,\n  {\n    name = (component as any)?.displayName || (component as any)?.name,\n    allowInheritance = null,\n    seperateRequest = false,\n  }: IGraphQLOptions = {}\n) => {\n  const query = new Query(name, false)\n  const state: any[] = []\n\n  const WithGraphQL = (props: Props) => {\n    let returnValue: any\n\n    const parentVariant = React.useContext(VariantContext)\n    const parentStack = React.useContext(StackContext)\n\n    const stack = React.useMemo((): StackContext => {\n      if (!parentStack.inheritance) return parentStack\n\n      return {\n        ...parentStack,\n        inheritance:\n          allowInheritance === null\n            ? parentStack.inheritance\n            : allowInheritance,\n        frames: seperateRequest ? [query] : [...parentStack.frames, query],\n      }\n    }, [seperateRequest || parentStack])\n\n    useComponentContext.value = {\n      variantFragments: undefined!,\n      lastStateIndex: -1,\n      state,\n      stack,\n      accessors: undefined!,\n      query,\n      schedulers: undefined!,\n    }\n\n    const {\n      accessors,\n      schedulers,\n      startIntercepting,\n      stopIntercepting,\n      updateAccessors,\n    } = useAccessors(stack)\n    Object.assign(useComponentContext.value, { accessors, schedulers })\n\n    const {\n      variantFragments,\n      startResolving,\n      stopResolving,\n      getRenderVariants,\n    } = useFragments()\n    Object.assign(useComponentContext.value, { variantFragments })\n\n    try {\n      startResolving()\n      startIntercepting()\n\n      returnValue = component(props)\n    } catch (e) {\n      throw e\n    } finally {\n      useComponentContext.value = undefined\n      stopIntercepting()\n      stopResolving()\n    }\n\n    // If we've recorded Abstract accessors in the\n    // variantFragments, then create an array\n    // containing all variants of the resolved types\n    //\n    // then return a new component for each variant,\n    // which will convert accessors into fragmentaccessors\n    // at render.\n    if (variantFragments.size) {\n      const renderVariants = getRenderVariants()\n\n      if (renderVariants.length)\n        return renderVariants.map((variant, i) => (\n          <VariantContext.Provider\n            key={i}\n            value={[...parentVariant, ...variant]}\n          >\n            <WithGraphQL {...props} />\n          </VariantContext.Provider>\n        ))\n    }\n\n    returnValue = (\n      <StackContext.Provider value={stack}>{returnValue}</StackContext.Provider>\n    )\n\n    const promise = updateAccessors()\n\n    // React suspense support\n    if (promise) {\n      let resolved = false\n      promise.then(() => (resolved = true))\n\n      // We can't directly throw the promise, otherwise\n      // child components (with data requirements) won't\n      // render - meaning multiple requests\n      //\n      // To prevent this we instead return a Fragment,\n      // which contains a component that throws the Promise.\n      const Suspend = () => {\n        // This is necessary to prevent an infinite loop\n        if (resolved) return null\n\n        throw promise\n      }\n\n      return (\n        <>\n          {returnValue}\n          <Suspend />\n        </>\n      )\n    }\n\n    return returnValue\n  }\n\n  WithGraphQL.displayName = `GraphQLComponent(${name || 'Component'})`\n  WithGraphQL.query = query\n\n  return WithGraphQL\n}\n","import { getAccessor, getAbstractImplementation } from 'gqless'\nimport { useComponentContext } from '../hooks/useComponentContext'\n\nexport function ofType<\n  TData extends { __typename: string },\n  T extends TData['__typename']\n>(data: TData, typename: T): data is TData & { __typename: T } {\n  try {\n    const { variantFragments } = useComponentContext()\n    const accessor = getAccessor(data)\n\n    const node = getAbstractImplementation(accessor.node, typename)\n    if (node) {\n      const fragment = accessor.getDefaultFragment(node)\n      if (!variantFragments.has(accessor))\n        variantFragments.set(accessor, new Set())\n\n      variantFragments.get(accessor)!.add(fragment)\n    }\n  } catch {\n    // useComponentContext / getAccessor could fail\n  }\n\n  return data.__typename === typename\n}\n"],"names":["useComponentContext","value","invariant","undefined","useComponentMemo","getValue","dependencies","context","stateIndex","lastStateIndex","memo","state","createMemo","useVariable","_1","_2","nullable","name","variable","Variable","useEffect","updateNullable","updateValue","usePoll","data","interval","initiallyPolling","accessor","getAccessor","stack","isPolling","setIsPolling","useState","poller","useMemo","Poller","frames","toggle","updateInterval","poll","useFragment","onType","fragmentName","FragmentAccessor","parent","node","NodeContainer","innerNode","nodeImplementation","getAbstractImplementation","fragment","Fragment","fragmentData","fragmentOn","useTracked","schedulers","callback","forEach","s","pushStack","popStack","StackContext","React","inheritance","Query","allowInheritance","children","parentStack","QueryCl","Array","isArray","map","Provider","useForceUpdate","_","setRerenders","timerRef","useRef","mountedRef","clearTimeout","current","timer","afterTransaction","setRef","rendered","setTimeout","r","useInterceptor","interceptor","Interceptor","Set","interceptedAccessors","onAccessor","listen","add","has","scheduler","startIntercepting","start","stopIntercepting","stop","useAccessors","accessors","accessorDisposers","Map","forceUpdate","disposers","dispose","updateAccessors","set","onDataChange","onStatusChange","newValue","prevValue","prevIdle","NetworkStatus","idle","active","nonIdleAccessors","status","loading","get","delete","size","Promise","resolve","then","VariantContext","createContext","useFragments","variant","useContext","variantFragments","stopResolving","startResolving","fragmentAccessor","a","selection","push","getRenderVariants","variants","fragments","length","newVariants","i","graphql","component","displayName","seperateRequest","query","WithGraphQL","props","returnValue","parentVariant","Object","assign","e","renderVariants","key","promise","resolved","Suspend","ofType","typename","getDefaultFragment","__typename"],"mappings":"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"}