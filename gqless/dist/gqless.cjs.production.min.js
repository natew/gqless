'use strict'
Object.defineProperty(exports, '__esModule', { value: !0 })
var t,
  e = require('mix-classes'),
  s = require('tslib'),
  n = require('@gqless/utils'),
  i =
    (t = require('json-stable-stringify')) &&
    'object' == typeof t &&
    'default' in t
      ? t.default
      : t
let o = 0
class r {
  constructor(t, e = t instanceof It ? [] : {}) {
    ;(this.node = t),
      (this.id = ++o),
      (this.references = new Map()),
      (this.onSet = n.createEvent()),
      (this.onChange = n.createEvent()),
      (this.onReference = n.createEvent()),
      (this.onUnreference = n.createEvent()),
      (this.data = e),
      this.onSet.listen((t, e) => {
        this.references.has(e) || this.references.set(e, new Set())
        const s = this.references.get(e)
        s.size || this.onReference.emit(e),
          s.add(t),
          this.onSet
            .filter(e => e === t)
            .then(() => {
              s.delete(t),
                s.size ||
                  (this.references.delete(e), this.onUnreference.emit(e))
            })
      })
  }
  get data() {
    return this._data
  }
  set data(t) {
    const e = this._data
    t !== e &&
      ((this._data = t),
      t &&
        'object' == typeof t &&
        Object.entries(t).forEach(([t, s]) => {
          ;(t = String(t)),
            (null == e ? void 0 : e[t]) !== s && this.onSet.emit(t, s)
        }),
      this.onChange.emit(e))
  }
  get(t) {
    if (
      this.data &&
      'object' == typeof this.data &&
      this.data.hasOwnProperty(t)
    )
      return this.data[t]
  }
  set(t, e) {
    var s
    ;(t = String(t)),
      (null === (s = this.data) || void 0 === s ? void 0 : s[t]) !== e &&
        ((this.data[t] = e), this.onSet.emit(t, e))
  }
  toJSON(t = !0) {
    if (!0 !== t) return this.data
    if (this.node instanceof It)
      return this.data ? this.data.map(t => t.toJSON()) : null
    if (this.node instanceof Mt) {
      if (!this.data) return null
      const t = { __typename: this.node.name }
      return (
        Object.entries(this.data).forEach(([e, s]) => {
          t[e] = s.toJSON()
        }),
        t
      )
    }
    return this.data
  }
}
const a = t => {
    const e = new Set(),
      s = n.createEvent(),
      i = n.createEvent()
    let o = new WeakMap([[t, { count: 1 }]])
    const r = t => {
        const n = new Set(),
          a = n => {
            o.has(n) || o.set(n, { count: 0 })
            const a = o.get(n),
              c = t.onUnreference.filter(t => t === n)
            if (
              (a.count++,
              c.then(() => {
                a.count--, a.count || i.emit(n)
              }),
              1 !== a.count)
            )
              return
            s.emit(n)
            const l = r(n)
            e.add(l), i.filter(t => t === n).then(l)
          }
        for (const e of t.references.keys()) a(e)
        return n.add(t.onReference.listen(a)), () => n.forEach(t => t())
      },
      a = r(t)
    return {
      onReference: s,
      onUnreference: i,
      dispose() {
        e.forEach(t => t()), a()
      },
    }
  },
  c = (t, e) =>
    new r(
      t,
      null === e ? null : t instanceof Ct || t instanceof xt ? e : void 0
    ),
  l = (t, e, ...s) => {
    const n = []
    for (const s of t) {
      const t = e(s)
      t && n.push(t)
    }
    for (const t of s) {
      const e = null == t ? void 0 : t.extension
      e && n.push(e)
    }
    return n
  }
class h {
  constructor(t) {
    ;(this.node = t),
      (this.keySelections = new Set()),
      (this.selections = new Set()),
      (this.onSelect = n.createEvent()),
      (this.onUnselect = n.createEvent())
  }
  add(t, e = !1) {
    t === this && n.invariant(!1),
      e && this.keySelections.add(t),
      this.selections.has(t) ||
        (this.selections.add(t),
        this.onSelect.emit(t),
        t.onSelect.listen(this.onSelect.emit),
        t.onUnselect.listen(this.onUnselect.emit))
  }
  get(t) {
    for (const e of this.selections)
      if ('function' == typeof t ? t(e) : String(e) === String(t)) return e
  }
  delete(t) {
    if (!this.selections.has(t)) return
    this.selections.delete(t),
      this.keySelections.delete(t),
      t.onSelect.off(this.onSelect.emit),
      t.onUnselect.off(this.onUnselect.emit)
    const e = t => {
      this.onUnselect.emit(t), t.selections.forEach(e)
    }
    e(t)
  }
  toString() {
    return String(this.node)
  }
}
class u {
  constructor(t, e = {}) {
    ;(this.options = e), Object.assign(this, e), this.updateValue(t)
  }
  updateValue(t) {
    t !== this.value &&
      (null === t && !1 === this.nullable && n.invariant(!1), (this.value = t))
  }
  updateNullable(t) {
    !0 === this.nullable && (t || n.invariant(!1)),
      !1 !== this.nullable && (this.nullable = t)
  }
  validateNode(t, e) {
    this.node || (this.node = t),
      this.node !== t && n.invariant(!1),
      void 0 !== e && this.updateNullable(e)
  }
  toString() {
    return `${this.node}${this.nullable ? '' : '!'}`
  }
  toJSON() {
    return this.value
  }
}
class d {
  constructor() {
    ;(this.disposers = new Set()), (this.disposed = !1)
  }
  addDisposer(...t) {
    return (
      t.forEach(t => 'function' == typeof t && this.disposers.add(t)),
      () => this.deleteDiposer(...t)
    )
  }
  deleteDiposer(...t) {
    t.forEach(t => 'function' == typeof t && this.disposers.delete(t))
  }
  dispose() {
    this.disposed ||
      ((this.disposed = !0), this.disposers.forEach(t => t.call(this)))
  }
}
const f = (t, e, s = (t, e) => `${t}${e}`) => {
    const n = (i = 2) => {
      const o = s(t, i)
      return e(o) ? n(i + 1) : o
    }
    return e(t) ? n() : t
  },
  p = (t, e, s) => {
    const n = null == s ? void 0 : s(t, e)
    if (void 0 !== n) return n
    if (
      (t && 'function' == typeof t.toJSON && (t = t.toJSON()),
      e && 'function' == typeof e.toJSON && (e = e.toJSON()),
      t === e)
    )
      return !0
    if (t && e && 'object' == typeof t && 'object' == typeof e) {
      if (t.constructor !== e.constructor) return !1
      let n, i, o, r
      if (Array.isArray(t)) {
        if ((n = t.length) !== e.length) return !1
        for (i = n; 0 != i--; ) if (!p(t[i], e[i], s)) return !1
        return !0
      }
      if ((n = (r = Object.keys(t)).length) !== Object.keys(e).length) return !1
      for (i = n; 0 != i--; )
        if (!Object.prototype.hasOwnProperty.call(e, r[i])) return !1
      for (i = n; 0 != i--; ) if (!p(t[(o = r[i])], e[o], s)) return !1
      return !0
    }
    return t != t && e != e
  }
class g extends Array {
  constructor(...t) {
    super(...t), Object.setPrototypeOf(this, Object.create(g.prototype))
  }
  toString() {
    return this.map(t => String(t)).join('.')
  }
}
const v = (t, e) =>
    t === e ||
    (null != t &&
      null != e &&
      t.length == e.length &&
      t.every((t, s) => e[s] === t)),
  m = ({ SPACE: t, SEPARATOR: e, options: s, formatter: n }, i, o) => {
    const r = (s, n, i) => {
        const o = Object.keys(s)
        return (
          o.sort(),
          o
            .map(e => {
              let o
              if (i) {
                const t = i.node.inputs[e]
                if (!t) return
                o = { node: t.ofNode, nullable: t.nullable }
              }
              const r = a(s[e], [...n, e], o)
              if (void 0 !== r) return `${e}:${t}${r}`
            })
            .filter(Boolean)
            .join(e)
        )
      },
      a = (i, c, l) => {
        if (s.variables && i instanceof u)
          return (({ options: t }, e, s) => {
            let n =
              e.name ||
              (t.prettify && (null == s ? void 0 : s.path)
                ? (t =>
                    t
                      .map((t, e) =>
                        0 === e ? t : t[0].toUpperCase() + t.substr(1)
                      )
                      .join(''))(s.path)
                : 'v')
            return (
              s &&
                (s.node && e.validateNode(s.node, s.nullable), s.variables) &&
                (s.variables.has(n) && (n = f(n, t => s.variables.has(t))),
                s.variables.set(n, e)),
              `$${n}`
            )
          })(n, i, { ...o, ...l, path: [...((o && o.path) || []), ...c] })
        if (
          (i && 'function' == typeof i.toJSON && (i = i.toJSON()), null === i)
        )
          return 'null'
        if ((null == l ? void 0 : l.node) instanceof xt) return i
        if (
          'string' == typeof i ||
          'number' == typeof i ||
          'boolean' == typeof i
        )
          return JSON.stringify(i)
        if ((null == l ? void 0 : l.node) instanceof Ct)
          return JSON.stringify(JSON.stringify(i))
        if (Array.isArray(i)) {
          let t
          if (l) {
            const e = l.node
            t = { node: e.ofNode, nullable: e.nullable }
          }
          return `[${i.map(e => a(e, c, t)).join(e)}]`
        }
        return `{${t}${r(i, c, l)}${t}}`
      }
    return r(i, [], o && { node: o.node, nullable: !1 })
  },
  x = ({ LINE_SEPARATOR: t, formatter: e }, s, n) => {
    const i =
      s.selection.node instanceof Pt
        ? s.selection.node.innerNode
        : s.selection.node
    if (i instanceof Ct || i instanceof xt) return ''
    const o = [
      !((s.children.length && i instanceof Mt) || s.selection instanceof O) &&
        '__typename',
      ...s.children.map(t => y(e, t, n)),
    ].filter(Boolean)
    return o.length ? o.join(t) : ''
  },
  y = ({ formatter: t }, e, s) =>
    e.selection instanceof D
      ? (({ SPACE: t, hug: e, indent: s, formatter: n }, i, o) =>
          `${(() => (i.alias ? `${i.alias}:${t}` : ''))()}${
            i.selection.field.name
          }${(() => {
            const t = i.selection.args
            return t
              ? `(${m(n, t, {
                  variables: o,
                  node: i.selection.field.args,
                  path: [i.selection.field.name],
                })})`
              : ''
          })()}${(() => {
            const r = x(n, i, o)
            return r ? `${t}${e(s(r))}` : ''
          })()}`)(t, e, s)
      : e.selection instanceof O
      ? (({ SPACE: t, hug: e, indent: s, formatter: n }, i) => {
          const o = i.allFragments.get(i.selection)
          if ('inline' !== n.options.fragments && o) return `...${o}`
          if (
            i.selection.node ===
            (i.parent.selection.node instanceof Pt
              ? i.parent.selection.node.innerNode
              : i.parent.selection.node)
          )
            return x(n, i)
          let r = x(n, i)
          if (!r) return ''
          let a = e(s(r))
          return `...${t}on ${i.selection.node}${t}${a}`
        })(t, e)
      : x(t, e, s)
let S = 0
const E = t => {
  if (t.parent) {
    for (const e of t.parent.children)
      if (
        e.selection instanceof D &&
        (t.selection !== e.selection || t.selection.field === e.selection.field)
      )
        return (
          (S = (S + 1) % Number.MAX_VALUE), `${t.selection.field.name}__${S}`
        )
    return ''
  }
}
function w(t) {
  const e = (t, s) => {
    if (s) {
      if (t instanceof Mt) {
        let t = new Map(),
          e = new Set()
        const i = n =>
          n.children.forEach(n => {
            if (n.selection instanceof O) return void i(n)
            if (!s.hasOwnProperty(n.key)) return
            const o = n.selection.toString()
            let r = s[n.key]
            t.has(n.key) && ((r = t.get(n.key)), t.delete(n.key)),
              n.key !== o &&
                (s.hasOwnProperty(o) && t.set(o, s[o]),
                (s[o] = r),
                e.add(o),
                e.has(n.key) || delete s[n.key]),
              n.resolveAliases(r)
          })
        i(this), t.size && n.invariant(!1)
      }
      t instanceof It && s.forEach(s => e(t.ofNode, s))
    }
  }
  e(this.selection.node, t)
}
class N {
  constructor(t, e) {
    ;(this.selection = t),
      (this.parent = e),
      (this.duplicatedFragments = this.parent
        ? this.parent.duplicatedFragments
        : new Map()),
      (this.allFragments = this.parent
        ? this.parent.allFragments
        : new WeakMap()),
      (this.children = []),
      (this.resolveAliases = w)
    const s = this.getExistingTree()
    if (s) return s
  }
  getExistingTree() {
    if (!(this.selection instanceof O)) return
    const t = this.selection
    if (this.allFragments.has(t)) {
      const e = this.allFragments.get(t)
      if (e) return this.duplicatedFragments.get(e)
      const s = f(t.toString(), t => this.duplicatedFragments.has(t))
      return (
        this.duplicatedFragments.set(s, this), void this.allFragments.set(t, s)
      )
    }
    this.allFragments.set(t, void 0)
  }
  get path() {
    return this.parent ? [...this.parent.path, this] : [this]
  }
  get alias() {
    if (this.selection instanceof D) return E(this)
  }
  get key() {
    if (this.selection instanceof D)
      return this.alias || this.selection.field.name
  }
  toString() {
    return this.path.map(t => t.selection.toString()).join('.')
  }
}
s.__decorate([n.computed], N.prototype, 'path', null),
  s.__decorate([n.computed], N.prototype, 'alias', null),
  s.__decorate([n.computed], N.prototype, 'key', null)
const b = t => {
    const e = new N({ toString: () => 'RootTree' }),
      s = (t, ...e) => {
        for (let n = 0; n < e.length; n++) {
          const i = e[n]
          if (
            i instanceof O &&
            !e.slice(n).find(t => !(t instanceof O) || t.selections.size)
          )
            return
          let o = t.children.findIndex(t => t.selection === i)
          if (o > -1) t = t.children[o]
          else {
            const e = new N(i, t)
            t.children.push(e), (t = e)
          }
          i.keySelections.forEach(e => {
            s(t, e)
          })
        }
        e[e.length - 1].selections.forEach(e => s(t, e))
      }
    return t.forEach(t => s(e, ...(Array.isArray(t) ? t : [t]))), e
  },
  _ = ({ SPACE: t, NEWLINE: e, hug: s, indent: n, formatter: i }, o) =>
    'inline' === i.options.fragments
      ? ''
      : Array.from(o.duplicatedFragments)
          .map(([e, o]) =>
            ((e, o) =>
              `fragment ${e} on ${o.selection.node}${t}${s(n(x(i, o)))}`)(e, o)
          )
          .join(e),
  A = (
    { SPACE: t, SEPARATOR: e, NEWLINE: s, hug: n, indent: i, formatter: o },
    r,
    ...a
  ) => {
    const c = b(a).children[0],
      l = new Map(),
      h = y(o, c, l),
      u = `${r ? ' ' + r : ''}${(() =>
        l.size
          ? `(${Array.from(l)
              .map(([e, s]) => `$${e}:${t}${s}`)
              .join(e)})`
          : '')()}`,
      d = [`${u ? `query${u}${t}` : ''}${n(i(h))}`, _(o, c)]
        .filter(Boolean)
        .join(s + s)
    let f
    return (
      l.size && ((f = {}), l.forEach((t, e) => (f[e] = t.toJSON()))),
      { rootTree: c, query: d, variables: f }
    )
  }
class k {
  constructor({
    prettify: t = !1,
    variables: e = !1,
    fragments: s = 'inline',
  } = {}) {
    ;(this.formatter = this),
      (this.indent = t =>
        this.SPACE ? t.replace(/^/gm, this.SPACE.repeat(2)) : t),
      (this.hug = t => `{${this.NEWLINE}${t}${this.NEWLINE}}`),
      (this.options = { prettify: t, variables: e, fragments: s }),
      (this.SPACE = t ? ' ' : ''),
      (this.SEPARATOR = `,${this.SPACE}`),
      (this.LINE_SEPARATOR = t ? '\n' : this.SEPARATOR),
      (this.NEWLINE = t ? '\n' : '')
  }
}
const $ = new k({ prettify: !1, variables: !1 })
class D extends h {
  constructor(t, e) {
    super(t.ofNode), (this.field = t), (this.args = e)
  }
  toString() {
    const t = this.args ? `(${m($, this.args, { node: this.field.args })})` : ''
    return this.field.name + t
  }
}
class O extends h {
  constructor(t, e) {
    super(t), (this.name = e)
  }
  toString() {
    return this.name || `${this.node || ''}Fragment`
  }
}
const C = (t, ...e) => {
  const s = []
  for (const n of e)
    n instanceof O
      ? s.push(...C(t, ...n.selections))
      : n.toString() === t && s.push(n)
  return s
}
class P {
  constructor(t) {
    ;(this.node = t), (this.instances = new Set()), (this.keys = new Map())
  }
  match(t) {
    this.node instanceof Ot || n.invariant(!1)
    for (const e of this.instances) {
      const s = this.node.match(e, t)
      if (s) return { value: e, exactValue: s }
    }
  }
  getByKey(t) {
    if (this.keys.has(t)) return this.keys.get(t)
    for (const [e, s] of this.keys) if (Nt(t, e)) return s
  }
  toJSON(t = !0) {
    const e = {}
    return (
      this.keys.forEach((s, n) => {
        e[i(n)] = !0 === t ? s.toJSON() : s
      }),
      {
        keys: e,
        instances: Array.from(this.instances).map(e =>
          !0 === t ? e.toJSON() : e
        ),
      }
    )
  }
}
const R = /^([^(]+)\(?/,
  T = (t, e, s, n = [], ...i) => {
    if (e.node instanceof Ct || e.node instanceof xt) return void F(e, s)
    const o = null === e.data,
      r = null === s
    if (!o || !r) {
      if (!r)
        return e.node instanceof Mt
          ? (o && (e.data = {}), j(t, e, s, n, ...i))
          : e.node instanceof It
          ? ((e.data = o ? [] : e.data.slice(0, s.length)), void I(t, e, s, n))
          : void 0
      e.data = null
    }
  },
  V = (t, e, s, n, ...i) => {
    const o = []
    for (const { fragment: t } of n) t && (o.includes(t) || o.push(t))
    if (!o.length) return
    const r = c(e, s),
      a = T(t, r, s, n, ...o),
      l = ((t, e, s) => {
        const n = e.node
        let i,
          o,
          r = t.entries.get(n)
        for (const t of s) {
          var a
          if (!t.isKeyable) continue
          const s = t.getKey(e)
          if (!wt(s)) continue
          wt(i) || (i = s)
          const n = null === (a = r) || void 0 === a ? void 0 : a.getByKey(s)
          if (!o && n && ((o = { key: s, value: n }), e)) return o
        }
        return (
          o ||
          (wt(i) && e
            ? (r || ((r = new P(n)), t.entries.set(n, r)),
              r.keys.set(i, e),
              { key: i, value: e })
            : void 0)
        )
      })(t, r, n)
    return l
      ? (l.value !== r ? T(t, l.value, s, n, ...i) : null == a || a(), l.value)
      : void 0
  },
  F = (t, e) => {
    t.data = e
  },
  I = (t, e, s, n, ...i) => {
    s.forEach((s, o) => {
      const r = e.node.ofNode,
        a = Tt(r, null == s ? void 0 : s.__typename),
        h = l(n, t => t.childIndex(), r, a, r)
      let u = e.get(o)
      const d = V(t, a || r, s, h, ...i)
      d
        ? e.set(o, d)
        : (u || ((u = c(a || r, s)), e.set(o, u)), T(t, u, s, h, ...i))
    })
  },
  j = (t, e, s, n, ...i) => {
    function o(i, ...o) {
      let r = i
      var a
      if (
        !(
          i in e.node.fields ||
          ((r = null === (a = r.match(R)) || void 0 === a ? void 0 : a[1]) &&
            r in e.node.fields)
        )
      )
        return
      const h = e.node.fields[r],
        u = s[i],
        d = h.ofNode,
        f = Tt(d, null == u ? void 0 : u.__typename),
        p = l(n, t => t.childField(h), f, d)
      let g = e.get(i)
      const v = V(t, f || d, u, p, ...o)
      v
        ? e.set(i, v)
        : (g || ((g = c(f || d, u)), e.set(i, g)), T(t, g, s[i], p, ...o))
    }
    const r = []
    for (const t in s) {
      if ('__typename' === t) continue
      const e = C(t, ...i)
      !i.length || e.length ? o(t, ...e) : r.push(() => o(t, ...e))
    }
    return r.length
      ? () => {
          for (const t of r) t()
        }
      : void 0
  },
  z = (t, e) => {
    if (t.value) return t.value
    const s = t.parent && z(t.parent),
      n = Tt(t.node, null == e ? void 0 : e.__typename),
      i = c(n || t.node, e)
    return s && s.set(t.toString(), i), i
  }
let M
class U {
  constructor() {
    this.callbacks = new Set()
  }
  begin() {
    M || (M = this)
  }
  end() {
    M === this && ((M = void 0), this.flush())
  }
  flush() {
    const t = Array.from(this.callbacks)
    this.callbacks.clear(), t.forEach(t => t())
  }
  onComplete(t) {
    this.callbacks.add(t)
  }
}
const J = t => {
  M ? M.onComplete(t) : t()
}
class K extends d {
  constructor(t) {
    super(),
      (this.entries = new Map()),
      (this.onRootValueChange = n.createEvent()),
      this.onRootValueChange.listen(() => {
        this.references && this.references.dispose(),
          (this.references = a(this.rootValue))
        const t = t => {
          this.entries.has(t.node) || this.entries.set(t.node, new P(t.node))
          const e = this.entries.get(t.node)
          e.instances.has(t) || e.instances.add(t)
        }
        t(this.rootValue),
          this.references.onReference.listen(t),
          this.references.onUnreference.listen(t => {
            this.entries.has(t.node) &&
              this.entries.get(t.node).instances.delete(t)
          })
      }),
      (this.rootValue = new r(t))
  }
  get rootValue() {
    return this._rootValue
  }
  set rootValue(t) {
    t !== this._rootValue &&
      ((this._rootValue = t), this.onRootValueChange.emit(t))
  }
  merge(t, e) {
    const s = new U()
    s.begin()
    const n = z(t, e)
    T(this, n, e, t.extensions), s.end()
  }
  toJSON(t = !0) {
    const e = {}
    return (
      this.entries.forEach(s => {
        e[s.node.toString()] = !0 === t ? s.toJSON() : s
      }),
      { data: !0 === t ? this.rootValue.toJSON() : this.rootValue, types: e }
    )
  }
  dispose() {
    super.dispose(), this.references.dispose()
  }
}
class q {
  constructor() {
    ;(this.plugins = []),
      (this.all = new Proxy(
        {},
        {
          get: (t, e) => (...t) =>
            this.plugins.filter(t => e in t).map(s => s[e](...t)),
        }
      )),
      (this.first = new Proxy(
        {},
        {
          get: (t, e) => (...t) => s => {
            for (const n of this.plugins.filter(t => e in t)) {
              const i = n[e](...t)
              if (s(i)) return i
            }
          },
        }
      ))
  }
  add(...t) {
    1 === t.length && 'function' == typeof t[0]
      ? (this.plugins = (0, t[0])(this.plugins))
      : this.plugins.push(...t)
  }
  remove(...t) {
    t.forEach(t => {
      const e = this.plugins.indexOf(t)
      e > -1 && this.plugins.splice(e, 1)
    })
  }
}
const B = t => {
  const e = new Map()
  t.forEach(t => {
    t.forEach((s, n) => {
      const i = t.length - n,
        o = (t => {
          if (e.has(t)) return e.get(t)
          const s = { amount: 0, count: 0 }
          return e.set(t, s), s
        })(s)
      o.count++, (o.amount += i)
    })
  })
  const s = Array.from(e).sort(
    ([, t], [, e]) => e.count - t.count || e.amount - t.amount
  )
  s.forEach(([t, e], n) => {
    if (n > 0) {
      const t = s[n - 1][1]
      if (e.amount / e.count == t.amount / t.count)
        return void (e.priority = t.priority)
    }
    e.priority = n
  })
  const n = new Set(),
    i = new Map()
  return t
    .map(t => {
      let s = []
      for (let n = t.length - 1; n >= 0; n--) {
        const i = t[n]
        e.get(i), s.push(i)
      }
      return (
        1 === s.length
          ? n.add(s[0])
          : s.forEach(t => {
              i.set(t, (i.get(t) || 0) + 1)
            }),
        s
      )
    })
    .map(t => {
      let e, s
      for (const o of t) {
        if (n.has(o)) return o
        const t = i.get(o)
        ;(void 0 === e || t > e) && ((e = t), (s = o))
      }
      return n.add(s), s
    })
}
class L {
  constructor(t, e) {
    if (((this.name = t), L.instances.has(t))) {
      if (!e) return L.instances.get(t)
    } else L.instances.set(t, this)
  }
  toString() {
    return this.name || '(unnamed)'
  }
}
L.instances = new Map()
const W = new L()
class G extends d {
  constructor(t, e, s) {
    super(),
      (this.plugins = t),
      (this.stack = e),
      (this.fetchAccessors = s),
      (this.onActive = n.createEvent()),
      (this.onIdle = n.createEvent()),
      (this.onFetched = n.createEvent()),
      (this.accessors = new Map())
  }
  stageUntilValue(t) {
    if (!t.resolved) return
    if (t.value) return
    const e = this.stage(t)
    return (
      this.addDisposer(
        t.onValueChange.then(e),
        t.onResolvedChange.then(t => {
          t || e()
        })
      ),
      e
    )
  }
  stage(t, ...e) {
    const s = () => this.unstage(t)
    return this.disposed || t.status !== exports.NetworkStatus.idle
      ? s
      : (this.accessors.size || this.onActive.emit(),
        (t.status = t.value
          ? exports.NetworkStatus.updating
          : exports.NetworkStatus.loading),
        this.accessors.set(t, [...this.stack, ...e]),
        t.parent && this.accessors.has(t.parent) && this.unstage(t.parent),
        s)
  }
  unstage(t) {
    this.disposed ||
      (this.accessors.has(t) && (t.status = exports.NetworkStatus.idle),
      this.accessors.delete(t),
      this.accessors.size || this.onIdle.emit())
  }
  async fetch() {
    if (!this.accessors.size) return
    const t = Array.from(this.accessors.keys()),
      e = Array.from(this.accessors.values()),
      s = B(e),
      n = new Map()
    s.forEach((e, i) => {
      void 0 === e && (s[i] = e = W)
      const o = t[i]
      n.has(e) ? n.get(e).push(o) : n.set(e, [o])
    }),
      this.plugins.all.onCommit({
        stacks: e,
        stackQueries: s,
        accessors: t,
        queries: n,
      })
    try {
      const t = Array.from(n)
        .map(async ([t, e]) => {
          const s = this.fetchAccessors(e, t && t.name)
          try {
            await s
          } finally {
            e.forEach(t => {
              t.status = exports.NetworkStatus.idle
            })
          }
        })
        .filter(Boolean)
      await Promise.all(t)
    } catch (t) {
      console.error(t)
    }
    this.onFetched.emit()
  }
}
class Q extends d {
  constructor(t, e = new q(), s = 50) {
    super(),
      (this.fetchAccessors = t),
      (this.plugins = e),
      (this.interval = s),
      (this.stack = []),
      (this.commit = void 0),
      this.startTimer(),
      this.addDisposer(this.clearTimer)
  }
  pushStack(...t) {
    this.stack.push(...t)
  }
  popStack(...t) {
    for (let e = t.length - 1; e >= 0; e--) {
      const s = this.stack.length - 1
      this.stack[s] !== t[e] && n.invariant(!1), this.stack.splice(s, 1)
    }
  }
  startTimer() {
    this.clearTimer(),
      (this.commit && !this.commit.accessors.size) ||
        (this.commit && this.commit.dispose(),
        (this.commit = new G(this.plugins, this.stack, this.fetchAccessors)))
    const { commit: t } = this
    t.onActive.then(() => {
      ;(this.timer = setTimeout(() => {
        t.fetch(), this.startTimer()
      }, this.interval)),
        t.onIdle.then(() => {
          t === this.commit && this.startTimer()
        })
    })
  }
  clearTimer() {
    clearTimeout(this.timer)
  }
}
const X = t => {
    const e = n.createEvent()
    let s
    const i = (n, i) => {
      var o
      null === (o = s) || void 0 === o || o(), (s = void 0)
      const r = () => {
        const s = null == n ? void 0 : n.data,
          o = null == i ? void 0 : i.data
        s !== o &&
          (void 0 !== o ||
            null === s ||
            t.node instanceof Ct ||
            t.node instanceof xt) &&
          e.emit(o)
      }
      n ? ((s = n.onChange.listen(r)), r()) : r()
    }
    return t.addDisposer(t.onValueChange.listen(i)), i(void 0, t.value), e
  },
  Y = (t, e, s = t.parent) => {
    if (!s) return
    const n = 'function' == typeof e,
      i = t => (n ? e(t) : t.get(e))
    let o
    const r = () => {
      if ((o && (t.deleteDiposer(o), o(), (o = void 0)), s.value)) {
        t.value = i(s.value)
        const r = n ? s.value.onChange : s.value.onSet.filter(t => t === e)
        return (
          (o = r.listen(() => {
            t.value = i(s.value)
          })),
          void t.addDisposer(o)
        )
      }
      t.value = void 0
    }
    t.addDisposer(s.onValueChange.listen(r)), r()
  },
  H = new Set()
class Z {
  constructor() {
    ;(this.listening = !1), (this.onAccessor = n.createEvent())
  }
  start() {
    H.add(this.onAccessor.emit), (this.listening = !0)
  }
  stop() {
    H.delete(this.onAccessor.emit), (this.listening = !1)
  }
}
var tt
;((tt = exports.NetworkStatus || (exports.NetworkStatus = {}))[(tt.idle = 0)] =
  'idle'),
  (tt[(tt.loading = 1)] = 'loading'),
  (tt[(tt.updating = 2)] = 'updating')
const et = Symbol(),
  st = new L('KeyedRefetch'),
  nt = n.createMemo()
class it extends d {
  constructor(t, e, s = e.node) {
    super(),
      (this.parent = t),
      (this.selection = e),
      (this.node = s),
      (this.extensions = []),
      (this.children = []),
      (this.scheduler = this.parent ? this.parent.scheduler : void 0),
      (this.cache = this.parent ? this.parent.cache : void 0),
      (this._status = exports.NetworkStatus.idle),
      (this._resolved = !0),
      (this.onValueChange = n.createEvent()),
      (this.onDataChange = X(this)),
      (this.onResolvedChange = n.createEvent()),
      (this.onStatusChange = n.createEvent()),
      (this.onInitializeExtensions = n.createEvent()),
      t &&
        (t.children.push(this),
        this.addDisposer(
          t.selection.onUnselect
            .filter(t => t === e)
            .listen(() => this.dispose())
        )),
      this.addDisposer(
        this.onDataChange.listen(() => {
          ;(this.data = void 0), this.loadExtensions()
        }),
        null == t
          ? void 0
          : t.onInitializeExtensions.listen(() => {
              this.loadExtensions()
            })
      )
  }
  get resolved() {
    return this._resolved
  }
  set resolved(t) {
    this._resolved !== t &&
      ((this._resolved = t), this.onResolvedChange.emit(t))
  }
  get data() {
    return this.fragmentToResolve
      ? this.fragmentToResolve.data
      : (void 0 === this._data && (this.data = this.getData()),
        H.forEach(t => t(this)),
        this._data)
  }
  set data(t) {
    this._data = t
  }
  set status(t) {
    const e = this._status
    ;(this._status = t), e !== t && this.onStatusChange.emit(t, e)
  }
  get status() {
    return this._status
  }
  set value(t) {
    const e = this._value
    ;(this._value = t), e !== t && this.onValueChange.emit(t, e)
  }
  get value() {
    return this._value
  }
  initializeExtensions() {
    const t = t => {
      let e = t.extension
      e &&
        (e instanceof kt && (e = new Dt(e, this)), this.extensions.unshift(e))
    }
    if (this.node instanceof Vt) for (const e of this.node.implementations) t(e)
    t(this.node)
  }
  loadExtensions() {
    const t = this.extensions
    if (
      ((this.extensions = []),
      this.initializeExtensions(),
      !v(t, this.extensions) &&
        (this.onInitializeExtensions.emit(),
        this.extensions.length &&
          ((!(this instanceof rt) || this.node !== this.parent.node) &&
            this.extensions.forEach(({ fragment: t }) => {
              t && this.selection !== t && this.selection.add(t, !0)
            }),
          !this.value && this.cache.entries.has(this.node))))
    )
      for (const t of this.extensions) {
        const e = t.redirect(this)
        if (e instanceof r) {
          this.updateValue(e)
          break
        }
      }
  }
  updateValue(t) {
    var e
    if (t === this.value) return
    ;(null === (e = this.parent) || void 0 === e ? void 0 : e.value) ||
      n.invariant(!1)
    const s = new Set(this.children.filter(t => !t.value))
    this.parent.value.set(this.toString(), t),
      J(() => {
        this.children.find(t => !t.value && !s.has(t)) &&
          this.scheduler.commit.stage(this, st)
      })
  }
  getData(t) {}
  setData(t) {
    console.log('set', this.path.toString(), t), this.cache.merge(this, t)
  }
  get(t) {
    return this.children.find(
      'function' == typeof t
        ? t
        : t instanceof h
        ? e => e.selection === t
        : e => e.toString() === String(t)
    )
  }
  getDefaultFragment(t) {
    return nt.fragment(() => {
      const e = new O(t)
      return this.selectionPath[this.selectionPath.length - 1].add(e), e
    }, [t, ...this.selectionPath])
  }
  get selectionPath() {
    const t = this.parent ? this.parent.selectionPath : new g()
    return t[t.length - 1] === this.selection ? t : new g(...t, this.selection)
  }
  get path() {
    return new g(...(this.parent ? this.parent.path : []), this)
  }
  dispose() {
    if ((super.dispose(), this.parent)) {
      const t = this.parent.children.indexOf(this)
      ;-1 !== t && this.parent.children.splice(t, 1),
        this.scheduler.commit.unstage(this),
        this.scheduler.commit.accessors.forEach((t, e) => {
          for (let t = 0; t < this.path.length; t++)
            if (this.path[t] !== e.path[t]) return
          this.scheduler.commit.unstage(e)
        })
    }
  }
}
s.__decorate([n.computed], it.prototype, 'selectionPath', null),
  s.__decorate([n.computed], it.prototype, 'path', null)
class ot extends it {
  constructor(t, e) {
    super(t, e),
      (this.parent = t),
      (this._resolved = this.parent.resolved),
      this.parent.onResolvedChange.listen(t => (this.resolved = t)),
      Y(this, this.toString()),
      this.loadExtensions(),
      this.scheduler.commit.stageUntilValue(this)
  }
  initializeExtensions() {
    super.initializeExtensions()
    for (let t = this.parent.extensions.length - 1; t >= 0; --t) {
      let e = this.parent.extensions[t].childField(this.selection.field)
      e &&
        (e instanceof kt && (e = new Dt(e, this)), this.extensions.unshift(e))
    }
  }
  getData(t) {
    return this.selection.field.ofNode.getData({ accessor: this, ...t })
  }
  toString() {
    return this.selection.toString()
  }
}
class rt extends it {
  constructor(t, e) {
    super(t, e),
      (this.parent = t),
      (this._resolved =
        this.parent.resolved &&
        (!this.parent.value || this.parent.value.node === this.selection.node)),
      e.node !== t.node &&
        this.parent.onValueChange.listen(t => {
          this.resolved = this.parent.resolved && (!t || t.node === e.node)
        }),
      Y(this, t => (t.node === e.node ? t : void 0)),
      this.loadExtensions()
  }
  startResolving() {
    const t = this.parent.fragmentToResolve
    this.parent.fragmentToResolve = this
    const e = () => {
        ;(this.parent.fragmentToResolve = t), s()
      },
      s = this.addDisposer(e)
    return e
  }
  initializeExtensions() {
    for (let t = this.parent.extensions.length - 1; t >= 0; --t) {
      const e = this.parent.extensions[t]
      e.node === this.selection.node && this.extensions.unshift(e)
    }
  }
  getData(t) {
    return this.selection.node.getData({ accessor: this, ...t })
  }
  toString() {
    return this.selection.toString()
  }
}
class at extends it {
  constructor(t, e) {
    super(t, t.selection, (t instanceof at ? t.node : t.selection.node).ofNode),
      (this.parent = t),
      (this.index = e),
      (this._resolved = this.parent.resolved),
      this.addDisposer(
        this.parent.onStatusChange.listen(t => {
          this.status = t
        })
      ),
      this.parent.onResolvedChange.listen(t => (this.resolved = t)),
      Y(this, this.toString()),
      this.loadExtensions(),
      this.scheduler.commit.stageUntilValue(this)
  }
  initializeExtensions() {
    super.initializeExtensions()
    for (let t = this.parent.extensions.length - 1; t >= 0; --t) {
      let e = this.parent.extensions[t].childIndex()
      e &&
        (e instanceof kt && (e = new Dt(e, this)), this.extensions.unshift(e))
    }
  }
  getData(t) {
    return this.selection.node.ofNode.getData({ accessor: this, ...t })
  }
  toString() {
    return `${this.index}`
  }
}
class ct extends it {
  constructor(t, e, s = new K(t.node)) {
    super(void 0, t),
      (this.scheduler = e),
      (this.cache = s),
      (this.value = s.rootValue),
      this.addDisposer(
        s.onRootValueChange.listen(() => (this.value = s.rootValue))
      ),
      this.loadExtensions()
  }
  getData(t) {
    return this.selection.node.getData({ accessor: this, ...t })
  }
  updateValue(t) {
    this.cache.rootValue = t
  }
  toString() {
    return this.selection.toString()
  }
}
let lt, ht
const ut = new Z()
ut.onAccessor.listen(t => {
  ;(lt = t),
    clearTimeout(ht),
    (ht = setTimeout(() => {
      lt = null
    }))
}),
  ut.start()
const dt = t => {
  if (t) {
    const e = t[et]
    if (e) return e
    if (t instanceof it) return t
  }
  return (
    null === lt && n.invariant(!1),
    lt || n.invariant(!1),
    lt.data !== t && n.invariant(!1),
    lt
  )
}
class ft {
  constructor(t, { name: e }) {
    ;(this.name = e),
      (this.fields = n.lazyGetters(t, (t, e) => {
        e.name = t
      }))
  }
  toString() {
    return this.name
  }
}
const pt = t => {
    t.accessor && H.forEach(e => e(t.accessor))
  },
  gt = t =>
    t.extensions ? t.extensions : t.accessor ? t.accessor.extensions : [],
  vt = t =>
    t.selection ? t.selection : t.accessor ? t.accessor.selection : void 0,
  mt = t => (t.value ? t.value : t.accessor ? t.accessor.value : void 0)
class xt {
  constructor({ name: t } = {}) {
    this.name = t
  }
  toString() {
    return this.name || this.constructor.name
  }
  getData(t) {
    pt(t)
    const e = mt(t)
    return e ? e.data : null
  }
}
const yt = Symbol(),
  St = Symbol(),
  Et = Symbol(),
  wt = t => null != t,
  Nt = (t, e) => p(t, e),
  bt = (t, e, s, n) => new ('function' == typeof e ? kt : $t)(s, t, e, n),
  _t = n.createMemo()
class At {
  constructor(t, e, s = t ? void 0 : e) {
    ;(this.parent = t), (this.node = e), (this.fragmentKeyedBy = s)
  }
  get fragmentKey() {
    return this.path.map(t => t.fragmentKeyedBy).filter(Boolean)
  }
  get fragment() {
    var t
    const e = null === (t = this.data) || void 0 === t ? void 0 : t[Et]
    if (!e) return
    let s = this.fragmentKey[this.fragmentKey.length - 1]
    return (
      s instanceof Pt && (s = s.innerNode),
      s instanceof ft
        ? _t.fragment(() => {
            const t = new O(s, `Keyed${this.fragmentKey.join('_')}`),
              n = s.getData({ selection: t })
            return e(n), t
          }, this.fragmentKey)
        : void 0
    )
  }
  get isKeyable() {
    var t
    return !!(null === (t = this.data) || void 0 === t ? void 0 : t[Et])
  }
  getKey(t) {
    var e
    const s = null === (e = this.data) || void 0 === e ? void 0 : e[Et]
    if (s) return s(t.node.getData({ value: t }))
  }
  redirect(t) {
    var e
    const s = null === (e = this.data) || void 0 === e ? void 0 : e[yt]
    if (!s) return
    const n = t.cache.entries.get(t.node)
    return n
      ? s(t instanceof ot ? t.selection.args : void 0, {
          instances: n.instances,
          match(t) {
            var e
            return null === (e = n.match(t)) || void 0 === e ? void 0 : e.value
          },
          getByKey: t => n.getByKey(t),
        })
      : void 0
  }
  childIndex() {
    return _t.childIndex(() => {
      var t
      this.node instanceof It || n.invariant(!1)
      const e = null === (t = this.data) || void 0 === t ? void 0 : t[St]
      if (void 0 !== e) return bt(this.node.ofNode, e, this)
    }, [this])
  }
  childField(t) {
    return _t.childField(() => {
      var e
      this.node instanceof ft || n.invariant(!1)
      const s = null === (e = this.data) || void 0 === e ? void 0 : e[t.name]
      if (void 0 !== s) return bt(t.ofNode, s, this, t)
    }, [this, t])
  }
  toString() {
    return this.fragmentKey.toString()
  }
  get path() {
    return new g(...(this.parent ? this.parent.path : []), this)
  }
}
s.__decorate([n.computed], At.prototype, 'fragmentKey', null),
  s.__decorate([n.computed], At.prototype, 'fragment', null),
  s.__decorate([n.computed], At.prototype, 'path', null)
class kt extends At {
  constructor(t, e, s, n) {
    super(t, e, n), (this.getData = s)
  }
  get data() {
    return this.getData(null)
  }
}
s.__decorate([n.computed], kt.prototype, 'data', null)
class $t extends At {
  constructor(t, e, s, n) {
    super(t, e, n), (this.data = s)
  }
}
class Dt extends At {
  constructor(t, e) {
    super(t, t.node), (this.accessor = e)
  }
  get data() {
    const t =
      this.accessor.node instanceof Ct
        ? this.accessor.getData({ extensions: [] })
        : this.accessor.data
    return this.parent.getData(t)
  }
}
s.__decorate([n.computed], Dt.prototype, 'data', null)
class Ot {
  match(t, e) {
    if (t.data === e) return t
    if ('function' == typeof e) {
      const s = e(t.data)
      return s ? (s instanceof r ? s : t) : null
    }
    return null === t.data || null === e ? null : void 0
  }
}
class Ct extends Ot {
  constructor({ name: t, extension: e } = {}) {
    super(), (this.name = t), e && (this.extension = bt(this, e))
  }
  match(t, e) {
    const s = super.match(t, e)
    return void 0 !== s
      ? s
      : e instanceof RegExp && String(t.data).match(e)
      ? t
      : void 0
  }
  toString() {
    return this.name || this.constructor.name
  }
  getData(t) {
    pt(t)
    const e = gt(t),
      s = mt(t),
      n = e[0]
    return n ? n.data : s ? s.data : null
  }
}
class Pt {
  constructor(t, e = !1) {
    ;(this.ofNode = t), (this.nullable = e)
  }
  get innerNode() {
    return this.ofNode instanceof Pt ? this.ofNode.innerNode : this.ofNode
  }
}
s.__decorate([n.computed], Pt.prototype, 'innerNode', null)
class Rt extends Pt {
  constructor(t, e, s) {
    super(t, s), (this.args = e), (this.name = '')
  }
  get uncallable() {
    return !(
      this.args &&
      (this.args.required ||
        this.ofNode instanceof Ct ||
        this.ofNode instanceof xt)
    )
  }
  getSelection(t, e) {
    pt(t)
    const s = vt(t)
    let n =
      null == s
        ? void 0
        : s.get(
            t =>
              t instanceof D &&
              t.field.name === this.name &&
              p(t.args, e, (t, e) => {
                if (t instanceof u || e instanceof u) return t === e
              })
          )
    return n || ((n = new D(this, e)), null == s || s.add(n), n)
  }
  getData(t) {
    const e = e => {
        var s
        return t.accessor
          ? (t.accessor.get(e) || new ot(t.accessor, e)).data
          : this.ofNode.getData({
              selection: e,
              value:
                null === (s = t.value) || void 0 === s
                  ? void 0
                  : s.get(e.toString()),
              extensions: [],
            })
      },
      s = s => {
        const n = s && (Object.keys(s).length ? s : void 0)
        return e(this.getSelection(t, n))
      }
    if (!this.uncallable) return s
    let i, o
    const r = () => (i ? o : ((i = this.getSelection(t)), (o = e(i))))
    return this.args
      ? new Proxy(s, {
          get: (t, e) => {
            const s = r()
            s || n.invariant(!1)
            const i = s[e]
            return 'function' == typeof i ? i.bind(s) : i
          },
          set: (t, e, s) => {
            const i = r()
            return i || n.invariant(!1), (i[e] = s), !0
          },
        })
      : r()
  }
  toString() {
    return this.name
  }
}
const Tt = (t, e) => {
  if (t instanceof Vt && e) {
    const s = t.implementations.find(t => t.toString() === e)
    return s || n.invariant(!1), s
  }
}
class Vt {
  constructor(t) {
    this.implementations = t
  }
  getData(t) {
    pt(t)
    const e = mt(t)
    if (e) {
      if (null === e.data) return null
      if (t.accessor) {
        const s = t.accessor.getDefaultFragment(e.node)
        return (t.accessor.get(s) || new rt(t.accessor, s)).data
      }
    }
    return new Proxy(
      {},
      {
        get: (e, s) => {
          var n, i
          const o =
            null === (n = t.accessor) || void 0 === n
              ? void 0
              : n.fragmentToResolve
          if (o) return null === (i = o.data) || void 0 === i ? void 0 : i[s]
          if (s === et) return t.accessor
          var r
          if ('__typename' === s)
            return null === (r = mt(t)) || void 0 === r
              ? void 0
              : r.node.toString()
          if ('toString' === s) return () => this.toString()
          for (const e of gt(t)) if (s in e.data) return e.data[s]
        },
        set: (e, s, n) => {
          var i
          const o =
            null === (i = t.accessor) || void 0 === i
              ? void 0
              : i.fragmentToResolve
          if (o) {
            const { data: t } = o
            return t && (t[s] = n), !0
          }
          for (const e of gt(t)) if (s in e) return (e.data[s] = n), !0
          return !0
        },
      }
    )
  }
  toString() {
    return this.implementations.join('|')
  }
}
const Ft = n.createMemo()
class It extends e.Mix(e.Generic(Pt), Ot) {
  constructor(t, e) {
    const s = Ft([t, e])
    if (s) return s
    super([t, e]), Ft(() => this, [t, e])
  }
  match(t, e) {
    const s = super.match(t, e)
    if (void 0 !== s) return s
    if (Array.isArray(e)) {
      if (e.length !== t.data.length) return
      if (
        e.find((s, n) => {
          const i = t.get(n)
          return !i || (i.node instanceof Ot ? !i.node.match(i, e[n]) : void 0)
        })
      )
        return
      return t
    }
    const n = t.node.innerNode
    if (n instanceof Ot)
      for (const s of t.data) {
        const t = n.match(s, e)
        if (t) return t
      }
  }
  getData(t) {
    pt(t)
    const e = new Proxy([], {
      get: (s, n) => {
        var i
        if (n === et) return t.accessor
        const o = null === (i = mt(t)) || void 0 === i ? void 0 : i.data
        var r
        if ('length' === n)
          return null !== (r = null == o ? void 0 : o.length) && void 0 !== r
            ? r
            : 1
        if ('toString' === n) return () => this.toString()
        if ('string' == typeof n) {
          const e = +n
          if (!isNaN(e)) {
            var a
            if (o && e >= o.length) return
            return t.accessor
              ? (t.accessor.get(e) || new at(t.accessor, e)).data
              : this.ofNode.getData({
                  value:
                    null === (a = t.value) || void 0 === a ? void 0 : a.get(e),
                  selection: t.selection,
                  extensions: [],
                })
          }
        }
        for (const e of gt(t)) if (n in e.data) return e.data[n]
        const c = s[n]
        return 'function' == typeof c ? c.bind(e) : c
      },
      has: (e, s) => {
        const n = mt(t)
        return n
          ? !!n.data && s in n.data
          : ('string' == typeof s && !isNaN(+s)) || s in e
      },
    })
    return e
  }
  toString() {
    return `[${this.ofNode}${this.nullable ? '' : '!'}]`
  }
}
class jt extends e.Mix(ft, e.Generic(Vt)) {
  constructor(t, e, s) {
    super([t, s], [e]), s.extension && (this.extension = bt(this, s.extension))
  }
  getData(t) {
    const e = super.getData(t)
    return e
      ? new Proxy(e, {
          get: (s, n) => {
            var i, o
            const r =
              null === (i = t.accessor) || void 0 === i
                ? void 0
                : i.fragmentToResolve
            return r
              ? null === (o = r.data) || void 0 === o
                ? void 0
                : o[n]
              : this.fields.hasOwnProperty(n)
              ? this.fields[n].getData(t)
              : e[n]
          },
          set: (s, n, i) => {
            var o
            const r =
              null === (o = t.accessor) || void 0 === o
                ? void 0
                : o.fragmentToResolve
            if (r) {
              const { data: t } = r
              return t && (t[n] = i), !0
            }
            if ('__typename' === n) return !0
            if (this.fields.hasOwnProperty(n)) {
              if (!t.accessor) return !0
              const s = this.fields[n].getSelection(t)
              return (t.accessor.get(s) || new ot(t.accessor, s)).setData(e), !0
            }
            return (e[n] = i), !0
          },
        })
      : e
  }
  toString() {
    return e.getMixin(this, ft).toString()
  }
}
const zt = new Ct()
class Mt extends e.Mix(ft, Ot) {
  constructor(t, e) {
    ;(t.__typename = new Rt(zt)),
      super([t, e]),
      e.extension && (this.extension = bt(this, e.extension))
  }
  match(t, e) {
    const s = super.match(t, e)
    if (void 0 !== s) return s
    let n = 0
    for (const s in e) {
      if (!this.fields.hasOwnProperty(s)) continue
      const i = this.fields[s]
      if (!(i.ofNode instanceof Ot)) continue
      const o = t.get(s),
        r = e[s]
      if (o) {
        if (!i.ofNode.match(o, r)) return
        n++
      }
    }
    return n ? t : void 0
  }
  getData(t) {
    const e = mt(t)
    return null === (null == e ? void 0 : e.data)
      ? null
      : new Proxy(
          {},
          {
            get: (e, s) => {
              var n, i
              const o =
                null === (n = t.accessor) || void 0 === n
                  ? void 0
                  : n.fragmentToResolve
              if (o)
                return null === (i = o.data) || void 0 === i ? void 0 : i[s]
              if (s === et) return t.accessor
              if ('__typename' === s) return this.name
              if (this.fields.hasOwnProperty(s))
                return this.fields[s].getData(t)
              if ('toString' === s) return () => this.toString()
              for (const e of gt(t)) if (s in e.data) return e.data[s]
            },
            set: (e, s, n) => {
              var i
              const o =
                null === (i = t.accessor) || void 0 === i
                  ? void 0
                  : i.fragmentToResolve
              if (o) {
                const { data: t } = o
                return t && (t[s] = n), !0
              }
              if ('__typename' === s) return !0
              if (this.fields.hasOwnProperty(s)) {
                if (!t.accessor) return !0
                const e = this.fields[s].getSelection(t)
                return (
                  (t.accessor.get(e) || new ot(t.accessor, e)).setData(n), !0
                )
              }
              for (const e of gt(t)) if (s in e.data) return (e.data[s] = n), !0
              return !0
            },
          }
        )
  }
}
;(exports.ACCESSOR = et),
  (exports.Abstract = Vt),
  (exports.Accessor = it),
  (exports.Arguments = class {
    constructor(t, e = !1) {
      ;(this.required = e),
        (this.inputs = n.lazyGetters(t, (t, e) => {
          e.name = t
        }))
    }
  }),
  (exports.ArgumentsField = class extends Pt {
    constructor(t, e) {
      super(t, e), (this.name = '')
    }
  }),
  (exports.ArrayNode = It),
  (exports.Cache = K),
  (exports.Client = class extends d {
    constructor(t, e, { prettifyQueries: s } = {}) {
      super(),
        (this.node = t),
        (this.fetchQuery = e),
        (this.plugins = new q()),
        (this.scheduler = new Q(
          (t, e) => this.fetchAccessors(t, e),
          this.plugins
        )),
        (this.cache = new K(this.node)),
        (this.selection = new h(this.node)),
        (this.accessor = new ct(this.selection, this.scheduler, this.cache)),
        (this.query = this.accessor.data),
        (this.formatter = new k({
          prettify: s,
          fragments: 'auto',
          variables: !0,
        })),
        this.selection.onSelect.listen(t => {
          this.plugins.all.onSelect(t)
        }),
        this.selection.onUnselect.listen(t => {
          this.plugins.all.onUnselect(t)
        })
    }
    fetchAccessors(t, e) {
      const s = A(this.formatter, e, ...t.map(t => t.selectionPath))
      if (!s) return
      const n = (async () => {
        const t = await this.fetchQuery(s.query, s.variables)
        return (
          s.rootTree.resolveAliases(t.data),
          this.cache.merge(this.accessor, t.data),
          t
        )
      })()
      return this.plugins.all.onFetch(t, n, s.variables, s.query, e), n
    }
    dispose() {
      super.dispose(), this.scheduler.dispose(), this.plugins.all.dispose()
    }
  }),
  (exports.ComputableExtension = kt),
  (exports.ComputedExtension = Dt),
  (exports.EnumNode = xt),
  (exports.Extension = At),
  (exports.FieldAccessor = ot),
  (exports.FieldNode = Rt),
  (exports.FieldSelection = D),
  (exports.FieldsNode = ft),
  (exports.Formatter = k),
  (exports.Fragment = O),
  (exports.FragmentAccessor = rt),
  (exports.GET_KEY = Et),
  (exports.INDEX = St),
  (exports.IndexAccessor = at),
  (exports.InputNode = class {
    constructor(t, { name: e }) {
      ;(this.name = e), (this.inputs = n.lazyGetters(t))
    }
    toString() {
      return this.name || this.constructor.name
    }
  }),
  (exports.InputNodeField = class extends Pt {
    constructor(t, e) {
      super(t, e)
    }
  }),
  (exports.Interceptor = Z),
  (exports.InterfaceNode = jt),
  (exports.Matchable = Ot),
  (exports.NodeContainer = Pt),
  (exports.NodeEntry = P),
  (exports.ObjectNode = Mt),
  (exports.Plugins = q),
  (exports.Poller = class {
    constructor(t, e, s) {
      ;(this.interval = e),
        (this.stack = s),
        (this.polling = !1),
        (this.accessor = dt(t))
    }
    updateInterval(t) {
      this.interval !== t && ((this.interval = t), this.resetTimer())
    }
    async poll() {
      ;(this.unstage = this.accessor.scheduler.commit.stage(
        this.accessor,
        ...(this.stack || [])
      )),
        await this.accessor.onStatusChange,
        (this.unstage = void 0),
        this.polling && this.pollAfterInterval()
    }
    pollAfterInterval() {
      this.timer = setTimeout(() => this.poll(), this.interval)
    }
    resetTimer() {
      this.polling && this.toggle(!0)
    }
    toggle(t = !this.polling) {
      var e
      ;(this.polling = t),
        null === (e = this.unstage) || void 0 === e || e.call(this),
        clearTimeout(this.timer),
        t && this.pollAfterInterval()
    }
  }),
  (exports.Query = L),
  (exports.REDIRECT = yt),
  (exports.RootAccessor = ct),
  (exports.ScalarNode = Ct),
  (exports.Scheduler = Q),
  (exports.Selection = h),
  (exports.SelectionTree = N),
  (exports.StaticExtension = $t),
  (exports.Transaction = U),
  (exports.UnionNode = class extends Vt {
    constructor(t) {
      super(t)
    }
  }),
  (exports.Value = r),
  (exports.Variable = u),
  (exports.accessorInterceptors = H),
  (exports.afterTransaction = J),
  (exports.buildArguments = m),
  (exports.buildQuery = A),
  (exports.buildSelectionTree = y),
  (exports.buildSelections = x),
  (exports.createExtension = bt),
  (exports.createValue = c),
  (exports.fragmentOn = (t, e) => {
    const s = dt(t)
    let n = (s instanceof rt ? s.parent : s).get(e)
    return n || (s.selection.add(e), (n = new rt(s, e))), n.data
  }),
  (exports.getAbstractImplementation = Tt),
  (exports.getAccessor = dt),
  (exports.getExtensions = gt),
  (exports.getSelection = vt),
  (exports.getValue = mt),
  (exports.interceptAccessor = pt),
  (exports.keyIsEqual = Nt),
  (exports.keyIsValid = wt),
  (exports.matchUpdate = (t, e) => {
    const s = dt(t),
      n = s.cache.entries.get(s.node)
    if (!n) return !1
    const i = n.match(e)
    return !!i && (s.updateValue(i.value), !0)
  }),
  (exports.merge = T),
  (exports.preload = (t, ...e) => {
    n.invariant(!1)
  }),
  (exports.refetch = t => {
    const e = dt(t)
    e.scheduler.commit.stage(e)
  }),
  (exports.resolved = function(t, e) {
    const s = t =>
      (null == e
      ? void 0
      : e.waitForUpdate)
        ? t.status === exports.NetworkStatus.idle
        : t.status !== exports.NetworkStatus.loading
    let n
    try {
      ;(n = dt(t)),
        (null == e ? void 0 : e.refetch) && n.scheduler.commit.stage(n)
    } catch (n) {
      if ('function' != typeof t) throw n
      const o = new Z(),
        r = new Set()
      o.onAccessor.listen(t => {
        r.has(t) ||
          (r.add(t),
          (null == e ? void 0 : e.refetch) && t.scheduler.commit.stage(t))
      }),
        o.start()
      try {
        var i = t()
      } finally {
        o.stop()
      }
      return new Promise((e, n) => {
        r.forEach(i => {
          if (s(i)) return void r.delete(i)
          const o = i.onStatusChange.listen(() => {
            if (s(i) && (o(), r.delete(i), !r.size))
              try {
                const s = t()
                e(s)
              } catch (t) {
                n(t)
              }
          })
        }),
          r.size || e(i)
      })
    }
    return s(n)
      ? Promise.resolve(t)
      : new Promise(t => {
          n.onStatusChange.listen(() => {
            s(n) && t(n.data)
          })
        })
  }),
  (exports.toTree = b),
  (exports.update = (t, e) => dt(t).setData(e))
//# sourceMappingURL=gqless.cjs.production.min.js.map
