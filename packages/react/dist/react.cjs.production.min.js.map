{"version":3,"file":"react.cjs.production.min.js","sources":["../src/hooks/useComponentContext.ts","../src/hooks/useComponentMemo.ts","../src/Query.tsx","../src/graphql/useFragments.ts","../src/graphql/graphql.tsx","../src/graphql/useAccessors.ts","../src/hooks/useForceUpdate.ts","../src/graphql/useInterceptor.ts","../src/ofType/ofType.ts","../src/hooks/useFragment.ts","../src/hooks/usePoll.ts","../src/hooks/useTracked.ts","../src/hooks/useVariable.ts"],"sourcesContent":["import { Query, Accessor, Fragment, ObjectNode, Scheduler } from 'gqless'\nimport { StackContext } from '../Query'\nimport { invariant } from '@gqless/utils'\n\nexport type VariantFragments = Map<Accessor, Set<Fragment>>\nexport type ComponentFragment = WeakMap<ObjectNode, Fragment>\n\nexport interface ComponentContext {\n  query: Query\n  stack: StackContext\n  accessors: Set<Accessor>\n  schedulers: Set<Scheduler>\n\n  // Fragments to be used for render variants\n  variantFragments: VariantFragments\n\n  // Global component state\n  lastStateIndex: number\n  state: any[]\n}\n\n/**\n * Returns the current context, for a component\n * wrapped in `graphql()`\n */\nexport const useComponentContext = () => {\n  invariant(\n    useComponentContext.value,\n    `not called within a wrapped graphql() component's render phase`\n  )\n\n  return useComponentContext.value\n}\n\nuseComponentContext.value = undefined as ComponentContext | undefined\n","import { createMemo } from '@gqless/utils'\nimport { useComponentContext } from './useComponentContext'\n\n/**\n * createMemo, persisted across all instances of Component\n */\nexport const useComponentMemo = <T>(\n  getValue: () => T,\n  dependencies?: any[]\n) => {\n  const context = useComponentContext()\n  const stateIndex = ++context.lastStateIndex\n\n  const memo: ReturnType<typeof createMemo> =\n    context.state[stateIndex] || (context.state[stateIndex] = createMemo())\n\n  return memo(getValue, dependencies)\n}\n","import * as React from 'react'\nimport { Query as QueryCl } from 'gqless'\n\nexport interface StackContext {\n  frames: QueryCl[]\n  inheritance: boolean\n}\n\nexport const StackContext = React.createContext<StackContext>({\n  frames: [],\n  inheritance: true,\n})\n\ntype QueryFrame = QueryCl | string | undefined\n\nexport const Query: React.SFC<{\n  value?: QueryFrame[] | QueryFrame | null\n  /**\n   * Whether or not child components can use their own queries.\n   *\n   * true  | child components can use their own queries\n   * false | (default) all queries will be merged into this components query\n   * null  | inherited with React context\n   */\n  allowInheritance?: boolean | null\n  children: any\n}> = ({\n  value = null,\n\n  allowInheritance = false,\n  children,\n}) => {\n  const parentStack = React.useContext(StackContext)\n\n  const stack: StackContext = React.useMemo(() => {\n    const frames =\n      value === null\n        ? parentStack.frames\n        : value instanceof QueryCl\n        ? [value]\n        : (Array.isArray(value) ? value : [value]).map(\n            value => new QueryCl(typeof value === 'string' ? value : undefined)\n          )\n\n    return {\n      frames,\n      inheritance:\n        allowInheritance === null ? parentStack.inheritance : allowInheritance,\n    }\n  }, [value, allowInheritance])\n\n  return <StackContext.Provider value={stack}>{children}</StackContext.Provider>\n}\n","import { VariantFragments } from '../hooks/useComponentContext'\nimport { Accessor, Fragment, FragmentAccessor, NetworkStatus } from 'gqless'\nimport { createContext, useContext } from 'react'\n\nexport type Variant = [Accessor, Fragment][]\nexport const VariantContext = createContext<Variant>([])\n\nexport const useFragments = () => {\n  const variant = useContext(VariantContext)\n  const variantFragments: VariantFragments = new Map()\n\n  const stopResolving: Function[] = []\n\n  return {\n    variantFragments,\n    startResolving() {\n      variant.forEach(([accessor, fragment]) => {\n        const fragmentAccessor =\n          accessor.get<FragmentAccessor>(a => a.selection === fragment) ||\n          new FragmentAccessor(accessor, fragment)\n\n        stopResolving.push(fragmentAccessor.startResolving())\n      })\n    },\n    stopResolving() {\n      stopResolving.forEach(stop => stop())\n    },\n    getRenderVariants() {\n      let variants: Variant[] = []\n\n      variantFragments.forEach((fragments, accessor) => {\n        // Only render variations for accessors\n        // without a value and non-idle\n        if (accessor.value || accessor.status === NetworkStatus.idle) return\n\n        if (!variants.length) {\n          fragments.forEach(fragment => variants.push([[accessor, fragment]]))\n          return\n        }\n\n        const newVariants: typeof variants = []\n        fragments.forEach(fragment => {\n          for (let i = 0; i < variants.length; i++) {\n            const variant = variants[i]\n            newVariants.push([...variant, [accessor, fragment]])\n          }\n        })\n        variants = newVariants\n      })\n\n      return variants\n    },\n  }\n}\n","import * as React from 'react'\nimport { Query } from 'gqless'\nimport { useComponentContext } from '../hooks/useComponentContext'\nimport { StackContext } from '../Query'\nimport { useAccessors } from './useAccessors'\nimport { useFragments, VariantContext } from './useFragments'\n\nexport interface IGraphQLOptions {\n  name?: string\n  seperateRequest?: boolean\n  /**\n   * Whether or not child components can use their own queries.\n   *\n   * true  | child components can use their own queries\n   * false | all queries will be merged into this components query\n   * null  | (default) inherited with React context\n   */\n  allowInheritance?: boolean | null\n}\n\nexport const graphql = <Props extends any>(\n  component: (props: Props) => any,\n  {\n    name = (component as any)?.displayName || (component as any)?.name,\n    allowInheritance = null,\n    seperateRequest = false,\n  }: IGraphQLOptions = {}\n) => {\n  const query = new Query(name, false)\n  const state: any[] = []\n\n  const WithGraphQL = (props: Props) => {\n    let returnValue: any\n\n    const parentVariant = React.useContext(VariantContext)\n    const parentStack = React.useContext(StackContext)\n\n    const stack = React.useMemo((): StackContext => {\n      if (!parentStack.inheritance) return parentStack\n\n      return {\n        ...parentStack,\n        inheritance:\n          allowInheritance === null\n            ? parentStack.inheritance\n            : allowInheritance,\n        frames: seperateRequest ? [query] : [...parentStack.frames, query],\n      }\n    }, [seperateRequest || parentStack])\n\n    useComponentContext.value = {\n      variantFragments: undefined!,\n      lastStateIndex: -1,\n      state,\n      stack,\n      accessors: undefined!,\n      query,\n      schedulers: undefined!,\n    }\n\n    const {\n      accessors,\n      schedulers,\n      startIntercepting,\n      stopIntercepting,\n      updateAccessors,\n    } = useAccessors(stack)\n    Object.assign(useComponentContext.value, { accessors, schedulers })\n\n    const {\n      variantFragments,\n      startResolving,\n      stopResolving,\n      getRenderVariants,\n    } = useFragments()\n    Object.assign(useComponentContext.value, { variantFragments })\n\n    try {\n      startResolving()\n      startIntercepting()\n\n      returnValue = component(props)\n    } catch (e) {\n      throw e\n    } finally {\n      useComponentContext.value = undefined\n      stopIntercepting()\n      stopResolving()\n    }\n\n    // If we've recorded Abstract accessors in the\n    // variantFragments, then create an array\n    // containing all variants of the resolved types\n    //\n    // then return a new component for each variant,\n    // which will convert accessors into fragmentaccessors\n    // at render.\n    if (variantFragments.size) {\n      const renderVariants = getRenderVariants()\n\n      if (renderVariants.length)\n        return renderVariants.map((variant, i) => (\n          <VariantContext.Provider\n            key={i}\n            value={[...parentVariant, ...variant]}\n          >\n            <WithGraphQL {...props} />\n          </VariantContext.Provider>\n        ))\n    }\n\n    returnValue = (\n      <StackContext.Provider value={stack}>{returnValue}</StackContext.Provider>\n    )\n\n    const promise = updateAccessors()\n\n    // React suspense support\n    if (promise) {\n      let resolved = false\n      promise.then(() => (resolved = true))\n\n      // We can't directly throw the promise, otherwise\n      // child components (with data requirements) won't\n      // render - meaning multiple requests\n      //\n      // To prevent this we instead return a Fragment,\n      // which contains a component that throws the Promise.\n      const Suspend = () => {\n        // This is necessary to prevent an infinite loop\n        if (resolved) return null\n\n        throw promise\n      }\n\n      return (\n        <>\n          {returnValue}\n          <Suspend />\n        </>\n      )\n    }\n\n    return returnValue\n  }\n\n  WithGraphQL.displayName = `GraphQLComponent(${name || 'Component'})`\n  WithGraphQL.query = query\n\n  return WithGraphQL\n}\n","import { Accessor, NetworkStatus } from 'gqless'\nimport { useMemo, useEffect } from 'react'\nimport { useForceUpdate } from '../hooks/useForceUpdate'\nimport { StackContext } from '../Query'\nimport { useInterceptor } from './useInterceptor'\n\nexport const useAccessors = (stack: StackContext) => {\n  const accessors = useMemo(() => new Set<Accessor>(), [])\n\n  const accessorDisposers = useMemo(() => new Map<Accessor, Function[]>(), [])\n  const forceUpdate = useForceUpdate()\n\n  useEffect(() => {\n    return () => {\n      accessorDisposers.forEach(disposers => {\n        disposers.forEach(dispose => dispose())\n      })\n    }\n  }, [])\n\n  const interceptor = useInterceptor(stack)\n\n  return {\n    ...interceptor,\n    accessors,\n    updateAccessors(): Promise<void> | void {\n      // Find all the new accessors and add to Set\n      interceptor.interceptedAccessors.forEach(accessor => {\n        if (accessors.has(accessor)) return\n\n        accessors.add(accessor)\n        accessorDisposers.set(\n          accessor,\n          // Make component update when data changes\n          [\n            accessor.onDataChange.listen(() => {\n              forceUpdate()\n            }),\n            accessor.onStatusChange.listen((newValue, prevValue) => {\n              const prevIdle = prevValue === NetworkStatus.idle\n              const active = newValue !== NetworkStatus.idle\n\n              if (prevIdle && active) {\n                forceUpdate()\n              }\n            }),\n          ]\n        )\n      })\n\n      const nonIdleAccessors = new Set<Accessor>()\n\n      accessors.forEach(accessor => {\n        // Locate accessors currently being fetched,\n        // and add to Set\n        if (interceptor.interceptedAccessors.has(accessor)) {\n          if (accessor.status === NetworkStatus.loading) {\n            nonIdleAccessors.add(accessor)\n          }\n\n          return\n        }\n\n        // Remove previously used accessors, that\n        // aren't required anymore\n        const disposers = accessorDisposers.get(accessor)\n        if (disposers) {\n          accessorDisposers.delete(accessor)\n          disposers.forEach(dispose => dispose())\n        }\n        accessors.delete(accessor)\n      })\n\n      if (nonIdleAccessors.size) {\n        return new Promise(resolve => {\n          nonIdleAccessors.forEach(accessor => {\n            accessor.onStatusChange.then(() => {\n              nonIdleAccessors.delete(accessor)\n              if (!nonIdleAccessors.size) resolve()\n            })\n          })\n        })\n      }\n    },\n  }\n}\n","import { useState, useRef, useEffect } from 'react'\nimport { afterTransaction } from 'gqless'\n\nexport const useForceUpdate = () => {\n  const [_, setRerenders] = useState(0)\n  const timerRef = useRef<{ rendered: boolean; timer: any; }>()\n  const mountedRef = useRef<boolean>(true)\n\n  useEffect(() => {\n    return () => {\n      clearTimeout(timerRef.current?.timer)\n      mountedRef.current = false\n    }\n  }, [])\n\n  return (callback?: Function) => afterTransaction(() => {\n    if (!mountedRef.current) return\n\n    const setRef = () => {\n      timerRef.current = { rendered: false, timer: setTimeout(() => {\n        timerRef.current = undefined\n      })}\n    }\n\n    if (!timerRef.current) setRef()\n    if (timerRef.current!.rendered) return\n\n    timerRef.current!.rendered = true\n    setRerenders(r => r + 1)\n    callback?.()\n  })\n}\n","import { Accessor, Interceptor, Scheduler } from 'gqless'\nimport { StackContext } from '../Query'\n\nexport const useInterceptor = (stack: StackContext) => {\n  // Create a new Interceptor, which tracks the usage\n  // of accessors\n  const interceptor = new Interceptor()\n\n  // When a new accessor is found, retrieve the\n  // scheduler associated with it\n  //\n  // Then call Scheduler#pushStack, with the\n  // component's stack\n  const schedulers = new Set<Scheduler>()\n  const interceptedAccessors = new Set<Accessor>()\n\n  // @ts-ignore\n  interceptor.onAccessor.listen(accessor => {\n    interceptedAccessors.add(accessor)\n\n    if (schedulers.has(accessor.scheduler)) return\n    schedulers.add(accessor.scheduler)\n\n    accessor.scheduler.pushStack(...stack.frames)\n  })\n\n  return {\n    interceptor,\n    schedulers,\n    interceptedAccessors,\n    startIntercepting() {\n      interceptor.start()\n    },\n    stopIntercepting() {\n      interceptor.stop()\n\n      // Cleanup the previous Scheduler#pushStack\n      // calls made earlier\n      schedulers.forEach(scheduler => {\n        scheduler.popStack(...stack.frames)\n      })\n    },\n  }\n}\n","import { getAccessor, getAbstractImplementation } from 'gqless'\nimport { useComponentContext } from '../hooks/useComponentContext'\n\nexport function ofType<\n  TData extends { __typename: string },\n  T extends TData['__typename']\n>(data: TData, typename: T): data is TData & { __typename: T } {\n  try {\n    const { variantFragments } = useComponentContext()\n    const accessor = getAccessor(data)\n\n    const node = getAbstractImplementation(accessor.node, typename)\n    if (node) {\n      const fragment = accessor.getDefaultFragment(node)\n      if (!variantFragments.has(accessor))\n        variantFragments.set(accessor, new Set())\n\n      variantFragments.get(accessor)!.add(fragment)\n    }\n  } catch {\n    // useComponentContext / getAccessor could fail\n  }\n\n  return data.__typename === typename\n}\n","import {\n  Fragment,\n  getAccessor,\n  NodeContainer,\n  ObjectNode,\n  fragmentOn,\n  FragmentAccessor,\n  getAbstractImplementation,\n} from 'gqless'\nimport { useMemo } from 'react'\nimport { useComponentMemo } from './useComponentMemo'\n\ntype OfType<TData, TTypename> = TData extends { __typename: TTypename }\n  ? TData\n  : never\n\n/**\n * Creates a new fragment (same across all instances of component)\n */\nexport function useFragment<\n  TData extends { __typename: string },\n  TTypename extends TData['__typename'] = never\n>(\n  data: TData,\n  onType?: TTypename,\n  fragmentName?: string\n): OfType<TData, TTypename> extends never ? TData : OfType<TData, TTypename> {\n  let accessor = getAccessor(data)\n\n  if (accessor instanceof FragmentAccessor) {\n    accessor = accessor.parent\n  }\n\n  const node = useMemo(() => {\n    const node =\n      accessor.node instanceof NodeContainer\n        ? accessor.node.innerNode\n        : accessor.node\n\n    if (onType) {\n      const nodeImplementation = getAbstractImplementation(node, onType)\n      if (nodeImplementation) return nodeImplementation\n    }\n\n    return node\n  }, [accessor.node, onType]) as ObjectNode\n\n  const fragment = useComponentMemo(() => new Fragment(node, fragmentName), [\n    node,\n  ])\n\n  useMemo(() => {\n    if (!fragmentName) return\n    fragment.name = fragmentName\n  }, [fragment, fragmentName])\n\n  const fragmentData = useMemo(() => fragmentOn(accessor, fragment), [\n    accessor,\n    fragment,\n  ])\n\n  return fragmentData\n}\n","import { getAccessor, Poller } from 'gqless'\nimport { useEffect, useMemo, useState } from 'react'\nimport { useComponentContext } from './useComponentContext'\n\nexport const usePoll = (\n  data: any,\n  interval: number,\n  initiallyPolling = true\n) => {\n  const accessor = getAccessor(data)\n  const { stack } = useComponentContext()\n  const [isPolling, setIsPolling] = useState(initiallyPolling)\n\n  const poller = useMemo(() => new Poller(accessor, interval, stack.frames), [\n    accessor,\n  ])\n  useEffect(() => () => poller.toggle(false), [accessor])\n\n  useEffect(() => {\n    poller.updateInterval(interval)\n  }, [interval])\n\n  useEffect(() => {\n    poller.toggle(isPolling)\n  }, [poller, isPolling])\n\n  return [\n    isPolling,\n    (poll = !isPolling) => {\n      setIsPolling(poll)\n    },\n  ] as const\n}\n","import { useComponentContext } from './useComponentContext'\n\nexport const useTracked = () => {\n  const { stack, schedulers } = useComponentContext()\n\n  return <T>(callback: () => T): T => {\n    try {\n      schedulers.forEach(s => s.pushStack(...stack.frames))\n      return callback()\n    } finally {\n      schedulers.forEach(s => s.popStack(...stack.frames))\n    }\n  }\n}\n","import { Variable } from 'gqless'\nimport { useMemo, useEffect } from 'react'\nimport { useComponentMemo } from './useComponentMemo'\n\nexport function useVariable<TValue>(\n  value: TValue,\n  name?: string\n): Variable<TValue>\n\nexport function useVariable<TValue>(\n  value: TValue,\n  nullable?: boolean,\n  name?: string\n): Variable<TValue>\n\nexport function useVariable(value: any, _1?: any, _2?: any) {\n  const nullable = typeof _1 === 'boolean' ? _1 : undefined\n  const name = _2 !== undefined ? _2 : typeof _1 === 'string' ? _1 : undefined\n\n  // TODO: useMemo\n  const variable = useComponentMemo(\n    () => new Variable(value, { name, nullable }),\n    []\n  )\n\n  useEffect(() => {\n    if (nullable === undefined) return\n\n    variable.updateNullable(nullable)\n  }, [variable, nullable])\n\n  useEffect(() => {\n    variable.updateValue(value)\n  }, [variable, value])\n\n  return variable\n}\n"],"names":["useComponentContext","value","invariant","undefined","useComponentMemo","getValue","dependencies","context","stateIndex","lastStateIndex","state","createMemo","StackContext","React","frames","inheritance","VariantContext","createContext","allowInheritance","children","parentStack","stack","QueryCl","Array","isArray","map","Provider","component","name","displayName","seperateRequest","query","Query","WithGraphQL","props","returnValue","parentVariant","variantFragments","accessors","schedulers","startIntercepting","stopIntercepting","updateAccessors","useMemo","Set","accessorDisposers","Map","forceUpdate","_","setRerenders","useState","timerRef","useRef","mountedRef","useEffect","clearTimeout","current","_timerRef$current","timer","callback","afterTransaction","rendered","setTimeout","r","useForceUpdate","forEach","disposers","dispose","interceptor","Interceptor","interceptedAccessors","onAccessor","listen","accessor","add","has","scheduler","pushStack","start","stop","popStack","useInterceptor","set","onDataChange","onStatusChange","newValue","prevValue","NetworkStatus","idle","nonIdleAccessors","status","loading","get","delete","size","Promise","resolve","then","useAccessors","Object","assign","startResolving","stopResolving","getRenderVariants","variant","useContext","fragment","fragmentAccessor","a","selection","FragmentAccessor","push","variants","fragments","length","newVariants","i","useFragments","e","renderVariants","key","promise","resolved","data","typename","getAccessor","node","getAbstractImplementation","getDefaultFragment","__typename","onType","fragmentName","parent","NodeContainer","innerNode","nodeImplementation","Fragment","fragmentOn","interval","initiallyPolling","isPolling","setIsPolling","poller","Poller","toggle","updateInterval","poll","s","_1","_2","nullable","variable","Variable","updateNullable","updateValue"],"mappings":"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"}