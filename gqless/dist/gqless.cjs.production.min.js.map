{"version":3,"file":"gqless.cjs.production.min.js","sources":["../src/Cache/Value.ts","../src/Cache/utils/deepReference.ts","../src/Cache/merge/createValue.ts","../src/Cache/merge/extensionsForKey.ts","../src/Selection/Selection.ts","../src/Variable/Variable.ts","../src/utils/mixins/Disposable.ts","../src/utils/uniquify.ts","../src/utils/deepJSONEqual.ts","../src/utils/PathArray.ts","../src/utils/camelCase.ts","../src/utils/arrayEqual.ts","../src/QueryBuilder/buildArguments.ts","../src/QueryBuilder/buildVariable.ts","../src/QueryBuilder/buildSelection.ts","../src/QueryBuilder/SelectionTree/getAlias.ts","../src/QueryBuilder/SelectionTree/resolveAliases.ts","../src/QueryBuilder/SelectionTree/SelectionTree.ts","../src/QueryBuilder/SelectionTree/toTree.ts","../src/QueryBuilder/buildFragments.ts","../src/QueryBuilder/buildQuery.ts","../src/QueryBuilder/Formatter.ts","../src/Selection/FieldSelection.ts","../src/Selection/Fragment.ts","../src/Cache/merge/selectionsForKey.ts","../src/Cache/NodeEntry.ts","../src/Cache/merge/merge.ts","../src/Cache/merge/getKeyFromCache.ts","../src/Cache/utils/createPath.ts","../src/Cache/Transaction.ts","../src/Cache/Cache.ts","../src/Plugin/Plugins.ts","../src/Scheduler/queriesFromStacks.ts","../src/Scheduler/Query.ts","../src/Scheduler/Commit.ts","../src/Scheduler/Scheduler.ts","../src/Accessor/utils/onDataChange.ts","../src/Accessor/utils/syncValue.ts","../src/Interceptor.ts","../src/Accessor/Accessor.ts","../src/Accessor/FieldAccessor.ts","../src/Accessor/FragmentAccessor.ts","../src/Accessor/IndexAccessor.ts","../src/Accessor/RootAccessor.ts","../src/Accessor/getAccessor.ts","../src/Node/abstract/FieldsNode/FieldsNode.ts","../src/Node/traits/Data.ts","../src/Node/EnumNode.ts","../src/Node/Extension/NodeExtension.ts","../src/Node/Extension/createExtension.ts","../src/Node/Extension/Extension.ts","../src/Node/Extension/ComputableExtension.ts","../src/Node/Extension/StaticExtension.ts","../src/Node/Extension/ComputedExtension.ts","../src/Node/abstract/Matchable.ts","../src/Node/ScalarNode.ts","../src/Node/abstract/NodeContainer.ts","../src/Node/abstract/FieldsNode/FieldNode.ts","../src/Node/abstract/Abstract.ts","../src/Node/ArrayNode.ts","../src/Node/InterfaceNode.ts","../src/Node/ObjectNode.ts","../src/Node/Arguments/Arguments.ts","../src/Node/Arguments/ArgumentsField.ts","../src/Client.ts","../src/Node/InputNode/InputNode.ts","../src/Node/InputNode/InputNodeField.ts","../src/helpers/Poller.ts","../src/Node/UnionNode.ts","../src/helpers/fragmentOn.ts","../src/helpers/matchUpdate.ts","../src/helpers/preload.ts","../src/helpers/refetch.ts","../src/helpers/resolved.ts","../src/helpers/update.ts"],"sourcesContent":["import { ArrayNode, ObjectNode, DataTrait } from '../Node'\nimport { createEvent } from '@gqless/utils'\n\nexport type UValueData =\n  | string\n  | number\n  | boolean\n  | { [key: string]: Value }\n  | Value[]\n  | null\n\nlet id = 0\n\nexport class Value<TNode extends DataTrait = DataTrait> {\n  public id = ++id\n\n  private _data!: UValueData\n  public references = new Map<Value, Set<string | number>>()\n\n  constructor(\n    public node: TNode,\n    data: UValueData = node instanceof ArrayNode ? [] : {}\n  ) {\n    this.data = data\n    this.onSet.listen((key, value) => {\n      if (!this.references.has(value)) this.references.set(value, new Set())\n\n      const referencedKeys = this.references.get(value)!\n\n      if (!referencedKeys.size) this.onReference.emit(value)\n      referencedKeys.add(key)\n\n      this.onSet\n        .filter(k => k === key)\n        .then(() => {\n          referencedKeys.delete(key)\n          if (referencedKeys.size) return\n\n          this.references.delete(value)\n          this.onUnreference.emit(value)\n        })\n    })\n  }\n\n  // When a new Value is associated with a key\n  public onSet = createEvent<(key: string | number, value: Value) => void>()\n  // When data is updated (reference equality)\n  public onChange = createEvent<(prevData?: UValueData) => void>()\n\n  // When a Value becomes referenced\n  public onReference = createEvent<(value: Value) => void>()\n  // When a Value becomes de-refenerced\n  public onUnreference = createEvent<(value: Value) => void>()\n\n  public get data() {\n    return this._data\n  }\n\n  public set data(data: UValueData) {\n    const prevData = this._data\n    if (data === prevData) return\n\n    this._data = data\n\n    if (data && typeof data === 'object') {\n      Object.entries(data).forEach(([key, value]) => {\n        key = String(key)\n        if ((prevData as any)?.[key] === value) return\n\n        this.onSet.emit(key, value)\n      })\n    }\n\n    this.onChange.emit(prevData)\n  }\n\n  public get(key: string | number): Value | undefined {\n    if (this.data && typeof this.data === 'object') {\n      if (this.data.hasOwnProperty(key)) {\n        return (this.data as any)[key]\n      }\n    }\n\n    return undefined\n  }\n\n  public set(key: string | number, value: Value) {\n    key = String(key)\n    const prevValue = (this.data as any)?.[key]\n    if (prevValue === value) return\n    ;(this.data as any)[key] = value\n    this.onSet.emit(key, value)\n  }\n\n  public toJSON(deep = true): any {\n    if (deep !== true) return this.data\n\n    if (this.node instanceof ArrayNode) {\n      if (!this.data) return null\n\n      return (this.data as any[]).map(value => value.toJSON())\n    }\n\n    if (this.node instanceof ObjectNode) {\n      if (!this.data) return null\n\n      const obj: any = {\n        __typename: this.node.name,\n      }\n\n      Object.entries(this.data).forEach(([key, value]) => {\n        obj[key] = value.toJSON()\n      })\n      return obj\n    }\n\n    return this.data\n  }\n}\n","import { Value } from '../Value'\nimport { createEvent } from '@gqless/utils'\n\nexport const deepReference = (rootValue: Value) => {\n  const disposers = new Set<Function>()\n  const onReference = createEvent<(value: Value) => void>()\n  const onUnreference = createEvent<(value: Value) => void>()\n\n  let valueReferences = new WeakMap<Value, { count: number }>([\n    [rootValue, { count: 1 }], // Prevent RootValue from being unreferenced (handled on Cache)\n  ])\n\n  const watchAndEmit = (parentValue: Value) => {\n    const watcherDisposers = new Set<Function>()\n\n    const handleReference = (value: Value) => {\n      if (!valueReferences.has(value)) valueReferences.set(value, { count: 0 })\n      const references = valueReferences.get(value)!\n      const unrefFromParent = parentValue.onUnreference.filter(v => v === value)\n\n      // Update reference count\n      references.count++\n      unrefFromParent.then(() => {\n        references.count--\n\n        if (references.count) return\n        onUnreference.emit(value)\n      })\n\n      // If there's another reference beside our own,\n      // delegate to it\n      if (references.count !== 1) return\n\n      onReference.emit(value)\n      const dispose = watchAndEmit(value)\n\n      // When the root is disposed, dispose watcher\n      disposers.add(dispose)\n      // else wait until value is globally unreferenced\n      onUnreference.filter(v => v === value).then(dispose)\n    }\n\n    // Handle references created, before watchAndEmit called\n    for (const ref of parentValue.references.keys()) {\n      handleReference(ref)\n    }\n\n    watcherDisposers.add(\n      // When the parent value references a new value\n      // recursively watch it\n      parentValue.onReference.listen(handleReference)\n    )\n\n    return () => watcherDisposers.forEach(dispose => dispose())\n  }\n\n  const disposeWatcher = watchAndEmit(rootValue)\n\n  return {\n    onReference,\n    onUnreference,\n    dispose() {\n      disposers.forEach(dispose => dispose())\n      disposeWatcher()\n    },\n  }\n}\n","import { Value } from '../Value'\nimport { EnumNode, ScalarNode, DataTrait } from '../../Node'\n\nexport const createValue = (node: DataTrait, data?: any) =>\n  new Value(\n    node,\n    // Only initialize with data if it's ScalarNode or EnumNode\n    data === null\n      ? null\n      : node instanceof ScalarNode || node instanceof EnumNode\n      ? data\n      : undefined\n  )\n","import { Extension, DataTrait } from '../../Node'\n\nexport const extensionsForKey = (\n  extensions: Extension[],\n  get: (e: Extension) => Extension | undefined,\n  ...nodes: DataTrait[]\n) => {\n  const keyedExtensions: Extension[] = []\n\n  for (const extension of extensions) {\n    const keyExtension = get(extension)\n    if (!keyExtension) continue\n    keyedExtensions.push(keyExtension)\n  }\n\n  for (const node of nodes) {\n    const extension = node?.extension\n    if (!extension) continue\n    keyedExtensions.push(extension)\n  }\n\n  return keyedExtensions\n}\n","import { createEvent, invariant } from '@gqless/utils'\nimport { DataTrait } from '../Node'\n\nexport class Selection<TNode extends DataTrait = DataTrait> {\n  // Selections that should be fetched with all queries\n  public keySelections = new Set<Selection>()\n  public selections = new Set<Selection>()\n\n  /**\n   * Emitted when a child selection is created\n   */\n  public onSelect = createEvent<(selection: Selection) => void>()\n  /**\n   * Emitted when a child selection is unselected\n   */\n  public onUnselect = createEvent<(selection: Selection) => void>()\n\n  constructor(public node: TNode) {}\n\n  public add(selection: Selection, isKeySelection = false) {\n    invariant(selection !== this, `Circular selections are not permitted!`)\n\n    if (isKeySelection) this.keySelections.add(selection)\n    if (this.selections.has(selection)) return\n\n    this.selections.add(selection)\n    this.onSelect.emit(selection)\n\n    // Forward events\n    selection.onSelect.listen(this.onSelect.emit)\n    selection.onUnselect.listen(this.onUnselect.emit)\n  }\n\n  public get<TSelection extends Selection>(\n    find: ((selection: Selection) => boolean) | string | number\n  ): TSelection | undefined {\n    for (const selection of this.selections) {\n      if (\n        typeof find === 'function'\n          ? find(selection)\n          : String(selection) === String(find)\n      )\n        return selection as any\n    }\n    return\n  }\n\n  public delete(selection: Selection) {\n    if (!this.selections.has(selection)) return\n    this.selections.delete(selection)\n    this.keySelections.delete(selection)\n\n    // Unforward events\n    selection.onSelect.off(this.onSelect.emit)\n    selection.onUnselect.off(this.onUnselect.emit)\n\n    const emitUnselect = (selection: Selection) => {\n      // Emit unselect for each selection\n      this.onUnselect.emit(selection)\n      selection.selections.forEach(emitUnselect)\n    }\n\n    emitUnselect(selection)\n  }\n\n  public toString() {\n    return String(this.node)\n  }\n}\n","import { invariant } from '@gqless/utils'\n\nimport { UArguments } from '../Node'\n\nexport interface IVariableOptions {\n  node?: UArguments\n  nullable?: boolean\n  /**\n   * GraphQL variable name to use.\n   *\n   * Conflicts are handled automatically\n   */\n  name?: string\n}\n\nexport class Variable<TValue = any> {\n  public node?: UArguments\n  public value?: TValue\n\n  public nullable?: boolean\n  public name?: string\n\n  constructor(value?: TValue, public options: IVariableOptions = {}) {\n    Object.assign(this, options)\n\n    this.updateValue(value)\n  }\n\n  public updateValue(value?: TValue) {\n    if (value === this.value) return\n\n    if (value === null) {\n      invariant(\n        this.nullable !== false,\n        `Can't set non-nullable variable of type ${this.node}, to null`\n      )\n    }\n\n    this.value = value\n  }\n\n  public updateNullable(nullable: boolean) {\n    if (this.nullable === true) {\n      invariant(\n        nullable,\n        `Can't convert a nullable variable of type ${this.node}, to non-nullable`\n      )\n    }\n\n    if (this.nullable !== false) {\n      this.nullable = nullable\n    }\n  }\n\n  public validateNode(node: UArguments, nullable?: boolean) {\n    if (!this.node) this.node = node\n\n    invariant(\n      this.node === node,\n      `Cannot change variable from type '${this.node}' to '${node}`\n    )\n\n    if (nullable !== undefined) {\n      this.updateNullable(nullable)\n    }\n  }\n\n  public toString() {\n    return `${this.node}${this.nullable ? '' : '!'}`\n  }\n\n  public toJSON() {\n    return this.value\n  }\n}\n","export class Disposable {\n  private disposers = new Set<Function>()\n\n  protected disposed = false\n\n  public addDisposer(...disposers: any[]) {\n    disposers.forEach(\n      dispose => typeof dispose === 'function' && this.disposers.add(dispose)\n    )\n    return () => this.deleteDiposer(...disposers)\n  }\n\n  public deleteDiposer(...disposers: any[]) {\n    disposers.forEach(\n      dispose => typeof dispose === 'function' && this.disposers.delete(dispose)\n    )\n  }\n\n  public dispose() {\n    if (this.disposed) return\n\n    this.disposed = true\n    this.disposers.forEach(dispose => dispose.call(this))\n  }\n}\n","export const uniquify = (\n  desiredName: string,\n  isTaken: (name: string) => boolean,\n  uniquify = (name: string, id: number) => `${name}${id}`\n) => {\n  const unique = (id = 2): string => {\n    const differentName = uniquify(desiredName, id)\n\n    return isTaken(differentName) ? unique(id + 1) : differentName\n  }\n  return isTaken(desiredName) ? unique() : desiredName\n}\n","export const deepJSONEqual = (\n  a: any,\n  b: any,\n  customCompare?: (a: any, b: any) => boolean | undefined\n) => {\n  const isEqual = customCompare?.(a,b)\n  if (isEqual !== undefined) return isEqual\n\n  // Called in JSON.stringify (currently not used internally)\n  if (a && typeof a.toJSON === 'function') a = a.toJSON()\n  if (b && typeof b.toJSON === 'function') b = b.toJSON()\n\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length: number, i: number, key: string, keys: string[]\n\n    if (Array.isArray(a)) {\n      length = a.length\n\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepJSONEqual(a[i], b[i], customCompare)) return false\n      return true\n    }\n\n    keys = Object.keys(a)\n    length = keys.length\n\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      key = keys[i]\n      if (!deepJSONEqual(a[key], b[key], customCompare)) return false\n    }\n\n    return true\n  }\n\n  return a !== a && b !== b\n}\n","export class PathArray<T> extends Array<T> {\n  constructor(...items: T[]) {\n    super(...items)\n    Object.setPrototypeOf(this, Object.create(PathArray.prototype))\n  }\n\n  public toString() {\n    return this.map(element => String(element)).join('.')\n  }\n}\n","export const camelCase = (value: string[]): string =>\n  value\n    .map((word: string, i: number) => {\n      if (i === 0) return word\n      return word[0].toUpperCase() + word.substr(1)\n    })\n    .join('')\n","export const arrayEqual = (a: any[], b: any[]) => {\n  if (a === b) return true\n  if (a == null || b == null) return false\n  if (a.length != b.length) return false\n\n  return a.every((value, i) => b[i] === value)\n}\n","import { Formatter } from './Formatter'\nimport { Variable } from '../Variable'\nimport { buildVariable, ConnectedVariable } from './buildVariable'\nimport {\n  Arguments,\n  InputNode,\n  ArrayNode,\n  EnumNode,\n  ScalarNode,\n  UArguments,\n} from '../Node'\n\ninterface ArgContext<TNode extends object = object> {\n  node: TNode\n  nullable: boolean\n}\n\nexport const buildArguments = (\n  { SPACE, SEPARATOR, options, formatter }: Formatter,\n  args: Record<string, any>,\n  info?: Omit<ConnectedVariable, 'nullable' | 'node'> & { node: Arguments }\n) => {\n  const buildKeyed = (\n    arg: Record<string, any>,\n    path: string[],\n    context?: ArgContext<Arguments | InputNode>\n  ) => {\n    const keys = Object.keys(arg)\n    keys.sort()\n\n    return keys\n      .map(key => {\n        let keyContext: ArgContext | undefined\n\n        if (context) {\n          const field = context.node.inputs[key]\n          if (!field) return\n\n          keyContext = {\n            node: field.ofNode,\n            nullable: field.nullable,\n          }\n        }\n\n        const result = build(arg[key], [...path, key], keyContext)\n        if (result === undefined) return\n\n        return `${key}:${SPACE}${result}`\n      })\n      .filter(Boolean)\n      .join(SEPARATOR)\n  }\n\n  const build = (\n    arg: any,\n    path: string[],\n    context?: ArgContext<any>\n  ): string => {\n    if (options.variables && arg instanceof Variable) {\n      return buildVariable(formatter, arg, {\n        ...info,\n        ...(context as ArgContext<UArguments>),\n        path: [...((info && info.path) || []), ...path],\n      })\n    }\n\n    if (arg && typeof arg.toJSON === 'function') arg = arg.toJSON()\n\n    if (arg === null) {\n      return 'null'\n    }\n\n    if (context?.node instanceof EnumNode) {\n      return arg\n    }\n\n    if (\n      typeof arg === 'string' ||\n      typeof arg === 'number' ||\n      typeof arg === 'boolean'\n    )\n      return JSON.stringify(arg)\n\n    if (context?.node instanceof ScalarNode) {\n      // Object / Array passed as scalar\n      // serialize as a JSON-string\n      return JSON.stringify(JSON.stringify(arg))\n    }\n\n    if (Array.isArray(arg)) {\n      let indexContext: ArgContext | undefined\n      if (context) {\n        const arrayNode = context.node as ArrayNode\n        indexContext = {\n          node: arrayNode.ofNode,\n          nullable: arrayNode.nullable,\n        }\n      }\n\n      return `[${arg.map(a => build(a, path, indexContext)).join(SEPARATOR)}]`\n    }\n\n    return `{${SPACE}${buildKeyed(arg, path, context)}${SPACE}}`\n  }\n\n  return buildKeyed(args, [], info && { node: info.node, nullable: false })\n}\n","import { Variable } from '../Variable'\nimport { UArguments } from '../Node'\nimport { uniquify, camelCase } from '../utils'\nimport { Formatter } from './Formatter'\n\nexport type Variables = Map<string, Variable>\n\nexport interface ConnectedVariable {\n  node?: UArguments\n  nullable?: boolean\n  variables?: Map<string, Variable>\n  path?: string[]\n}\n\nexport const buildVariable = ({ options }:  Formatter, variable: Variable, info?: ConnectedVariable) => {\n  let name =\n    variable.name! || (options.prettify && info?.path ? camelCase(info.path) : 'v')\n\n  if (info) {\n    if (info.node) variable.validateNode(info.node, info.nullable)\n\n    if (info.variables) {\n      const existingVariable = info.variables.has(name)\n\n      if (existingVariable) {\n        name = uniquify(name, name => info.variables!.has(name))\n      }\n\n      info.variables.set(name, variable)\n    }\n  }\n\n  return `$${name}`\n}\n","import { SelectionTree } from './SelectionTree'\nimport { FieldSelection, Fragment } from '../Selection'\nimport { Formatter } from './Formatter'\nimport { buildArguments } from './buildArguments'\nimport { EnumNode, NodeContainer, ObjectNode, ScalarNode } from '../Node'\nimport { Variables } from './buildVariable'\n\nexport const buildSelections = (\n  { LINE_SEPARATOR, formatter }: Formatter,\n  tree: SelectionTree,\n  variables?: Variables\n) => {\n  const innerNode =\n    tree.selection.node instanceof NodeContainer\n      ? tree.selection.node.innerNode\n      : tree.selection.node\n\n  if (innerNode instanceof ScalarNode || innerNode instanceof EnumNode)\n    return ''\n\n  const includeTypename =\n    // When no selections or not on ObjectNode\n    (!tree.children.length || !(innerNode instanceof ObjectNode)) &&\n    // fragments should never need __typename\n    !(tree.selection instanceof Fragment)\n\n  const selections = [\n    includeTypename && '__typename',\n    ...tree.children.map(tree =>\n      buildSelectionTree(formatter, tree, variables)\n    ),\n  ].filter(Boolean)\n\n  if (!selections.length) return ''\n\n  return selections.join(LINE_SEPARATOR)\n}\n\nconst buildFieldSelectionTree = (\n  { SPACE, hug, indent, formatter }: Formatter,\n  tree: SelectionTree<FieldSelection>,\n  variables?: Variables\n): string => {\n  const buildAlias = () => {\n    if (!tree.alias) return ''\n    return `${tree.alias}:${SPACE}`\n  }\n\n  const buildArgs = () => {\n    const args = tree.selection.args\n    if (!args) return ''\n\n    return `(${buildArguments(formatter, args, {\n      variables,\n      node: tree.selection.field.args!,\n      path: [tree.selection.field.name],\n    })})`\n  }\n\n  const buildChildren = () => {\n    const selections = buildSelections(formatter, tree, variables)\n    if (!selections) return ''\n\n    return `${SPACE}${hug(indent(selections))}`\n  }\n\n  return `${buildAlias()}${\n    tree.selection!.field.name\n  }${buildArgs()}${buildChildren()}`\n}\n\nconst buildFragmentTree = (\n  { SPACE, hug, indent, formatter }: Formatter,\n  tree: SelectionTree<Fragment>\n) => {\n  const fragmentName = tree.allFragments.get(tree.selection)\n\n  if (formatter.options.fragments !== 'inline' && fragmentName) {\n    return `...${fragmentName}`\n  }\n\n  const parentNode =\n    tree.parent!.selection.node instanceof NodeContainer\n      ? tree.parent!.selection.node.innerNode\n      : tree.parent!.selection.node\n\n  // If it's on the same node, and inline then omit type\n  if (tree.selection.node === parentNode) {\n    return buildSelections(formatter, tree)\n  }\n\n  let selections = buildSelections(formatter, tree)\n  if (!selections) return ''\n\n  let huggedSelections = hug(indent(selections))\n\n  // Add comment with fragment name (for debugging)\n  if (__DEV__ && formatter.options.prettify && tree.selection.name) {\n    huggedSelections = huggedSelections.replace(\n      '{',\n      `{ #[${tree.selection.name}]`\n    )\n  }\n\n  return `...${SPACE}on ${tree.selection.node}${SPACE}${huggedSelections}`\n}\n\nexport const buildSelectionTree = (\n  { formatter }: Formatter,\n  tree: SelectionTree,\n  variables?: Variables\n): string => {\n  if (tree.selection instanceof FieldSelection)\n    return buildFieldSelectionTree(formatter, tree as any, variables)\n\n  if (tree.selection instanceof Fragment)\n    return buildFragmentTree(formatter, tree as any)\n\n  return buildSelections(formatter, tree, variables)\n}\n","import { SelectionTree } from './SelectionTree'\nimport { FieldSelection } from '../../Selection'\nimport { createMemo } from '@gqless/utils'\n\nconst memoized = createMemo()\nlet id = 0\n\nexport const getAlias = (tree: SelectionTree<FieldSelection>) => {\n  if (!tree.parent) return\n\n  for (const siblingTree of tree.parent.children) {\n    if (siblingTree.selection instanceof FieldSelection) {\n      if (\n        tree.selection !== siblingTree.selection ||\n        tree.selection.field === siblingTree.selection.field\n      ) {\n        id = (id + 1) % Number.MAX_VALUE\n        return `${tree.selection.field.name}__${id}`\n      }\n    }\n  }\n\n  return ''\n\n  // this was causing issues with names - we need to add id to every field\n  // plus the memoization in prod mode caused a big bug\n  // const fieldAliases = memoized(() => {\n  //   const aliases = new Map<FieldSelection, string>()\n\n  //   let id = 0\n  //   tree.parent!.children.forEach(siblingTree => {\n  //     if (!(siblingTree.selection instanceof FieldSelection)) return\n\n  //     if (\n  //       tree.selection === siblingTree.selection ||\n  //       tree.selection.field !== siblingTree.selection.field\n  //     )\n  //       return\n\n  //     aliases.set(tree.selection, `${tree.selection.field.name}__${++id}`)\n  //   })\n  //   return aliases\n  // }, [tree.parent, tree.selection.field])\n\n  // return fieldAliases.get(tree.selection)!\n}\n","import { SelectionTree } from './SelectionTree'\nimport { invariant } from '@gqless/utils'\nimport { ObjectNode, ArrayNode } from '../../Node'\nimport { Fragment } from '../../Selection'\n\n/**\n * Resolves aliases from a JSON object, back into cache-compatible\n * keys\n *\n * eg. user -> user(id: 100)\n */\nexport function resolveAliases(this: SelectionTree, data: any) {\n  const recurse = (node: object, data: any) => {\n    if (!data) return\n\n    if (node instanceof ObjectNode) {\n      let originals = new Map<string, any>()\n      let updated = new Set<string>()\n\n      const recurseObjectTree = (tree: SelectionTree) =>\n        tree.children.forEach(tree => {\n          if (tree.selection instanceof Fragment) {\n            recurseObjectTree(tree)\n            return\n          }\n\n          if (!data.hasOwnProperty(tree.key!)) return\n          const cacheKey = tree.selection.toString()\n\n          let value = data[tree.key!]\n          if (originals.has(tree.key!)) {\n            value = originals.get(tree.key!)\n            originals.delete(tree.key!)\n          }\n\n          if (tree.key !== cacheKey) {\n            // If the key already exists, record original value\n            if (data.hasOwnProperty(cacheKey))\n              originals.set(cacheKey, data[cacheKey])\n\n            data[cacheKey] = value\n            updated.add(cacheKey)\n\n            // Only delete, if it hasn't been updated\n            if (!updated.has(tree.key!)) delete data[tree.key!]\n          }\n\n          tree.resolveAliases(value)\n        })\n\n      recurseObjectTree(this)\n\n      invariant(\n        !originals.size,\n        `Unable to resolve aliases for keys ${Array.from(originals.keys())\n          .map(k => `'${k}'`)\n          .join(', ')} [at path ${this.toString()}]`\n      )\n    }\n\n    if (node instanceof ArrayNode) {\n      ;(data as any[]).forEach(indexData => recurse(node.ofNode, indexData))\n    }\n  }\n\n  recurse(this.selection.node, data)\n}\n","import { Selection, FieldSelection, Fragment } from '../../Selection'\nimport { getAlias } from './getAlias'\nimport { computed } from '@gqless/utils'\nimport { uniquify } from '../../utils'\nimport { resolveAliases } from './resolveAliases'\n\nexport class SelectionTree<TSelection extends Selection = Selection> {\n  public duplicatedFragments: Map<string, SelectionTree<Fragment>> = this.parent\n    ? (this.parent as any).duplicatedFragments\n    : new Map()\n\n  public allFragments: WeakMap<Fragment, string | undefined> = this.parent\n    ? (this.parent as any).allFragments\n    : new WeakMap()\n\n  public children: SelectionTree[] = []\n\n  constructor(public selection: TSelection, public parent?: SelectionTree) {\n    const fragmentTree = this.getExistingTree()\n\n    if (fragmentTree) return fragmentTree as any\n  }\n\n  private getExistingTree(): SelectionTree<Fragment> | void {\n    if (!(this.selection instanceof Fragment)) return\n    const fragment: Fragment = this.selection as any\n\n    // If it already exists, convert from inline->named\n    if (this.allFragments.has(fragment)) {\n      // only if not already named,\n      const existingName = this.allFragments.get(fragment)\n      if (existingName) return this.duplicatedFragments.get(existingName)\n\n      const name = uniquify(fragment.toString(), name =>\n        this.duplicatedFragments.has(name)\n      )\n\n      this.duplicatedFragments.set(name, this as any)\n      this.allFragments.set(fragment, name)\n      return\n    }\n\n    // Add as inline first\n    this.allFragments.set(fragment, undefined)\n  }\n\n  public resolveAliases = resolveAliases\n\n  @computed\n  public get path(): SelectionTree<any>[] {\n    return this.parent ? [...this.parent.path, this] : [this]\n  }\n\n  @computed\n  public get alias(): string | undefined {\n    if (!(this.selection instanceof FieldSelection)) return\n    return getAlias(this as any)\n  }\n\n  @computed\n  public get key() {\n    if (!(this.selection instanceof FieldSelection)) return\n    return this.alias || this.selection.field.name\n  }\n\n  public toString() {\n    return this.path.map(t => t.selection.toString()).join('.')\n  }\n}\n","import { Selection, Fragment } from '../../Selection'\nimport { SelectionTree } from './SelectionTree'\n\nexport const toTree = (selections: (Selection | Selection[])[]) => {\n  const rootTree = new SelectionTree({ toString: () => 'RootTree' } as any)\n\n  const addSelectionToTree = (\n    tree: SelectionTree<any>,\n    ...pathToSelection: Selection[]\n  ) => {\n    for (let i = 0; i < pathToSelection.length; i++) {\n      const selection = pathToSelection[i]\n\n      // Filter out empty fragments\n      if (selection instanceof Fragment) {\n        // try and find a non-empty fragment somewhere after the path\n        // TODO fixme: this doesn't work for nested fragments that are empty\n        // eg.\n        //  frag A { ... B } -> A should be ignored\n        //  frag B { }\n        const validSelection = pathToSelection\n          .slice(i)\n          .find(s => !(s instanceof Fragment) || s.selections.size)\n\n        if (!validSelection) return\n      }\n\n      let index = tree.children.findIndex(t => t.selection === selection)\n      if (index > -1) {\n        tree = tree.children[index]\n      } else {\n        const newTree = new SelectionTree(selection, tree)\n        tree.children.push(newTree)\n        tree = newTree\n      }\n\n      // Add all the keySelections to the tree\n      selection.keySelections.forEach(keySelection => {\n        addSelectionToTree(tree, keySelection)\n      })\n    }\n\n    const selection = pathToSelection[pathToSelection.length - 1]\n\n    selection.selections.forEach(selection =>\n      addSelectionToTree(tree, selection)\n    )\n  }\n\n  selections.forEach(selections =>\n    addSelectionToTree(\n      rootTree,\n      ...(Array.isArray(selections) ? selections : [selections])\n    )\n  )\n\n  return rootTree\n}\n","import { SelectionTree } from './SelectionTree'\nimport { Formatter } from './Formatter'\nimport { Fragment } from '../Selection'\nimport { buildSelections } from './buildSelection'\n\nexport const buildFragments = (\n  { SPACE, NEWLINE, hug, indent, formatter }: Formatter,\n  tree: SelectionTree\n) => {\n  if (formatter.options.fragments === 'inline') return ''\n\n  const buildFragment = (\n    name: string,\n    fragmentTree: SelectionTree<Fragment>\n  ) => {\n    return `fragment ${name} on ${fragmentTree.selection.node}${SPACE}${hug(\n      indent(buildSelections(formatter, fragmentTree))\n    )}`\n  }\n\n  return Array.from(tree.duplicatedFragments)\n    .map(([name, tree]) => buildFragment(name, tree))\n    .join(NEWLINE)\n}\n","import { Formatter } from './Formatter'\nimport { Selection } from '../Selection'\nimport { toTree, SelectionTree } from './SelectionTree'\nimport { buildSelectionTree } from './buildSelection'\nimport { Variables } from './buildVariable'\nimport { ObjectNode } from '../Node'\nimport { buildFragments } from './buildFragments'\n\nexport const buildQuery = (\n  { SPACE, SEPARATOR, NEWLINE, hug, indent, formatter }: Formatter,\n  queryName?: string,\n  ...selectionPaths: Selection[][]\n) => {\n  const rootTree = toTree(selectionPaths).children[0] as SelectionTree<\n    Selection<ObjectNode>\n  >\n  const variablesMap: Variables = new Map()\n  const selections = buildSelectionTree(formatter, rootTree, variablesMap)\n\n  const buildVariables = () => {\n    if (!variablesMap.size) return ''\n\n    return `(${Array.from(variablesMap)\n      .map(([name, variable]) => `$${name}:${SPACE}${variable}`)\n      .join(SEPARATOR)})`\n  }\n\n  const queryHeader = `${queryName ? ' ' + queryName : ''}${buildVariables()}`\n\n  const query = [\n    `${queryHeader ? `query${queryHeader}${SPACE}` : ''}${hug(\n      indent(selections)\n    )}`,\n    buildFragments(formatter, rootTree),\n  ]\n    .filter(Boolean)\n    .join(NEWLINE + NEWLINE)\n\n  let variables: Record<string, any> | undefined\n\n  if (variablesMap.size) {\n    variables = {}\n    variablesMap.forEach(\n      (variable, name) => (variables![name] = variable.toJSON())\n    )\n  }\n\n  return { rootTree, query, variables }\n}\n\nexport * from './SelectionTree'\n","export interface IFormatterOptions {\n  /**\n   * Makes the query human readable\n   * @default process.env.NODE_ENV === 'development'\n   */\n  prettify?: boolean\n\n  /**\n   * Output GraphQL variables references.\n   * If set to false, variable values will be inlined\n   * @default false\n   */\n  variables?: boolean\n\n  /**\n   * Whether or not to extract fragments into a shared definition\n   * inline: all fragments will be inlined\n   * auto: all fragments will be inlined, unless duplicated\n   * @default inline\n   */\n  fragments?: 'auto' | 'inline'\n}\n\nexport class Formatter {\n  public formatter = this\n  public options: Required<IFormatterOptions>\n\n  public SPACE: string\n  public SEPARATOR: string\n  public LINE_SEPARATOR: string\n  public NEWLINE: string\n\n  constructor({\n    prettify = __DEV__,\n    variables = false,\n    fragments = 'inline',\n  }: IFormatterOptions = {}) {\n    this.options = {\n      prettify,\n      variables,\n      fragments,\n    }\n\n    this.SPACE = prettify ? ' ' : ''\n    this.SEPARATOR = `,${this.SPACE}`\n    this.LINE_SEPARATOR = prettify ? `\\n` : this.SEPARATOR\n    this.NEWLINE = prettify ? '\\n' : ''\n  }\n\n  public indent = (string: string) => {\n    if (!this.SPACE) return string\n\n    return string.replace(/^/gm, this.SPACE.repeat(2))\n  }\n\n  public hug = (string: string) => {\n    return `{${this.NEWLINE}${string}${this.NEWLINE}}`\n  }\n}\n","import { buildArguments, Formatter } from '../QueryBuilder'\n\nimport { FieldNode, DataTrait } from '../Node'\nimport { Selection } from './Selection'\n\nconst argsFormatter = new Formatter({ prettify: false, variables: false })\n\nexport class FieldSelection<\n  TNode extends DataTrait = DataTrait\n> extends Selection<TNode> {\n  constructor(\n    public field: FieldNode<TNode>,\n    public readonly args?: Record<string, any>\n  ) {\n    super(field.ofNode)\n  }\n\n  public toString() {\n    const args = this.args\n      ? `(${buildArguments(argsFormatter, this.args, {\n          node: this.field.args!,\n        })})`\n      : ''\n\n    return this.field.name + args\n  }\n}\n","import { Selection } from './Selection'\nimport { ObjectNode, InterfaceNode } from '../Node'\n\nexport type UFragment = ObjectNode | InterfaceNode\n\nexport class Fragment<TNode extends UFragment = UFragment> extends Selection<\n  TNode\n> {\n  constructor(node: TNode, public name?: string) {\n    super(node)\n  }\n\n  public toString() {\n    return this.name || `${this.node || ''}Fragment`\n  }\n}\n","import { Selection, Fragment } from '../../Selection'\n\nexport const selectionsForKey = (\n  key: string,\n  ...selectionsFilter: Selection[]\n) => {\n  const selections: Selection[] = []\n\n  for (const selection of selectionsFilter) {\n    if (selection instanceof Fragment) {\n      selections.push(...selectionsForKey(key, ...selection.selections))\n      continue\n    }\n\n    if (selection.toString() === key) {\n      selections.push(selection)\n    }\n  }\n\n  return selections\n}\n","import { Value } from './Value'\nimport { Matchable, keyIsEqual, DataTrait } from '../Node'\nimport { invariant } from '@gqless/utils'\nimport stringify from 'json-stable-stringify'\n\nexport class NodeEntry {\n  public instances = new Set<Value>()\n  public keys = new Map<any, Value>()\n\n  constructor(public node: DataTrait) {}\n\n  public match(data: any) {\n    invariant(\n      this.node instanceof Matchable,\n      `${this.node} does not support pattern matching`\n    )\n\n    for (const value of this.instances) {\n      const exactValue = this.node.match(value, data)\n      if (exactValue)\n        return {\n          value,\n          exactValue,\n        }\n    }\n\n    return\n  }\n\n  public getByKey(key: any) {\n    // First try and find key directly\n    if (this.keys.has(key)) return this.keys.get(key)\n\n    // else find structurally equal value\n    for (const [possibleKey, value] of this.keys) {\n      if (keyIsEqual(key, possibleKey)) return value\n    }\n\n    return undefined\n  }\n\n  public toJSON(deep = true) {\n    const keys: Record<string, any> = {}\n\n    this.keys.forEach((value, key) => {\n      keys[stringify(key)] = deep === true ? value.toJSON() : value\n    })\n\n    return {\n      keys,\n      instances: Array.from(this.instances).map(value =>\n        deep === true ? value.toJSON() : value\n      ),\n    }\n  }\n}\n","import { Value } from '../Value'\nimport { EnumNode, ObjectNode, ScalarNode, ArrayNode, DataTrait, Extension, FieldNode, UFieldsNode, getAbstractImplementation } from '../../Node'\nimport { createValue } from './createValue'\nimport { Selection, Fragment } from '../../Selection'\nimport { extensionsForKey } from './extensionsForKey'\nimport { selectionsForKey } from './selectionsForKey'\nimport { Cache } from '../Cache'\nimport { getKeyFromCache } from './getKeyFromCache'\n\nconst FIELD_NAME = /^([^(]+)\\(?/\n\n\n/**\n * Merge-updates a value\n * @param value value to update\n * @param data data to merge\n * @param extensions (optional) pass to enable cache keys\n * @param selectionsFilter (optional) pass to filter merging\n *\n * @returns mergeFiltered - merges the data omitted by selectionsFilter\n */\nexport const merge = (cache: Cache, value: Value, data: any, extensions: Extension[] = [], ...selectionsFilter: Selection[]): Function | undefined => {\n  if (value.node instanceof ScalarNode || value.node instanceof EnumNode) {\n    mergeScalar(value as any, data)\n    return\n  }\n\n  const wasNull = value.data === null\n  const isNull = data === null\n\n  // don't do anything if both are null\n  if (wasNull && isNull) return\n\n  // simply update for null\n  if (isNull) {\n    value.data = null\n    return\n  }\n\n  if (value.node instanceof ObjectNode) {\n    if (wasNull) value.data = {}\n    return iterateObject(cache, value as any, data, extensions, ...selectionsFilter)\n  }\n\n  if (value.node instanceof ArrayNode) {\n    // Update the array length (removing values if needed)\n    value.data = wasNull ? [] : (value.data as any[]).slice(0, data.length)\n    iterateArray(cache, value as any, data, extensions)\n    return\n  }\n  return\n}\n\nconst keyedMerge = (cache: Cache, node: DataTrait, data: any, extensions: Extension[], ...selectionsFilter: Selection[]) => {\n  const keyFragments: Fragment[] = []\n  for (const { fragment } of extensions) {\n    if (!fragment) continue\n    if (keyFragments.includes(fragment)) continue\n    keyFragments.push(fragment)\n  }\n  if (!keyFragments.length) return\n\n  // Create a *temporary* value with the fields needed to perform a key-operation\n  const keyedValue = createValue(node, data)\n\n  // Merge only the fields required for a key-op into the new value\n  const completeMerge = merge(cache, keyedValue, data, extensions, ...keyFragments)\n\n  // Find a key, and get value from cache\n  const result = getKeyFromCache(cache, keyedValue, extensions)\n\n  // No result, discard keyedValue\n  if (!result) return\n\n  // If the value was already in the cache,\n  // discard keyedValue and merge oncemore\n  if (result.value !== keyedValue) {\n    merge(cache, result.value, data, extensions, ...selectionsFilter)\n  } else {\n    // Value wasn't in cache, so merge the rest of data\n    // on the keyedValue\n    completeMerge?.()\n  }\n\n  return result.value\n}\n\nconst mergeScalar = (value: Value<ScalarNode>, data: any) => {\n  // Scalar's can't be keyed, so simply update\n  value.data = data\n}\n\nconst iterateArray = (cache: Cache, arrayValue: Value<ArrayNode<DataTrait>>, data: any[], arrayExtensions: Extension[], ...selectionsFilter: Selection[]) => {\n  data.forEach((data, key) => {\n    const node = arrayValue.node.ofNode\n    const nodeImplementation = getAbstractImplementation(node, data?.__typename)\n    const extensions = extensionsForKey(arrayExtensions, e => e.childIndex(), node, nodeImplementation, node)\n\n    let value = arrayValue.get(key)\n\n    const keyedValue = keyedMerge(cache, nodeImplementation || node, data, extensions, ...selectionsFilter)\n    if (keyedValue) {\n      arrayValue.set(key, keyedValue)\n      return\n    }\n\n    if (!value) {\n      value = createValue(nodeImplementation || node, data)\n      arrayValue.set(key, value)\n    }\n\n    merge(cache, value, data, extensions, ...selectionsFilter)\n  })\n}\n\nconst iterateObject = (cache: Cache, objectValue: Value<ObjectNode>, objectData: Record<string, any>, objectExtensions: Extension[], ...selectionsFilter: Selection[]) => {\n  function mergeObjectKey(key: string, ...filteredSelections: Selection[]) {\n    let fieldName = key\n    if (!(key in objectValue.node.fields))  {\n      fieldName = fieldName.match(FIELD_NAME)?.[1]!\n      if (!fieldName || !(fieldName in objectValue.node.fields)) return\n    }\n\n    const field = objectValue.node.fields[fieldName] as FieldNode<UFieldsNode & DataTrait>\n    const data = objectData[key]\n    const node = field.ofNode\n    const nodeImplementation = getAbstractImplementation(node, data?.__typename)\n    const extensions = extensionsForKey(objectExtensions, e => e.childField(field), nodeImplementation, node)\n\n    let value = objectValue.get(key)\n\n    const keyedValue = keyedMerge(cache, nodeImplementation || node, data, extensions, ...filteredSelections)\n    if (keyedValue) {\n      objectValue.set(key, keyedValue)\n      return\n    }\n\n    if (!value) {\n      value = createValue(nodeImplementation || node, data)\n      objectValue.set(key, value)\n    }\n\n    merge(\n      cache,\n      value,\n      objectData[key],\n      extensions,\n      ...filteredSelections\n    )\n  }\n\n  const mergeFiltered: Function[] = []\n\n  for (const key in objectData) {\n    if (key === '__typename') continue\n\n    const selections = selectionsForKey(key, ...selectionsFilter)\n\n    // If it's not selected, add to mergeFiltered\n    if (selectionsFilter.length && !selections.length) {\n      mergeFiltered.push(() => mergeObjectKey(key, ...selections))\n      continue\n    }\n\n    mergeObjectKey(key, ...selections)\n  }\n\n  return mergeFiltered.length ? () => {\n    for (const merge of mergeFiltered) {\n      merge()\n    }\n  } : undefined\n}\n","import { Value } from '../Value'\nimport { keyIsValid, Extension } from '../../Node'\nimport { NodeEntry } from '../NodeEntry'\nimport { Cache } from '../Cache'\n\nexport const getKeyFromCache = (cache: Cache, value: Value, extensions: Extension[]) => {\n  const node = value.node\n\n  let entry = cache.entries.get(node)\n\n  // Iterate through extensions and call GET_KEY\n  // if the key exists in the cache, then return it\n  // else create a new cache entry\n  let preferedKey: unknown\n  let result: { key: any, value: Value } | undefined\n  for (const extension of extensions) {\n    if (!extension.isKeyable) continue\n\n    const key = extension.getKey(value)\n    if (!keyIsValid(key)) continue\n    if (!keyIsValid(preferedKey)) preferedKey = key\n\n    // Check to see if the key already exists in cache\n    const keyedValue = entry?.getByKey(key)\n\n    if (!result && keyedValue) {\n      result = { key, value: keyedValue }\n      // if there's no value, complete loop before returning\n      if (value) return result\n    }\n  }\n\n  if (result) return result\n\n  // no keyed extension found\n  if (!keyIsValid(preferedKey) || !value) return\n\n  if (!entry) {\n    entry = new NodeEntry(node)\n    cache.entries.set(node, entry)\n  }\n\n  // add a new key to cache\n  entry.keys.set(preferedKey, value)\n\n  return { key: preferedKey, value }\n}\n","import { Accessor } from '../../Accessor'\nimport { createValue } from '../merge'\nimport { getAbstractImplementation } from '../../Node'\n\nexport const createPath = (accessor: Accessor, data?: any) => {\n  if (accessor.value) return accessor.value\n\n  const parentValue = accessor.parent && createPath(accessor.parent)\n  const nodeImplementation = getAbstractImplementation(accessor.node, data?.__typename)\n  const value = createValue(nodeImplementation || accessor.node, data)\n\n  if (parentValue) {\n    parentValue!.set(accessor.toString(), value)\n  }\n\n  return value\n}\n","let currentTransaction: Transaction | undefined\n\nexport class Transaction {\n  private callbacks = new Set<Function>()\n\n  public begin() {\n    if (currentTransaction) return\n    currentTransaction = this\n  }\n\n  public end() {\n    if (currentTransaction !== this) return\n    currentTransaction = undefined\n    this.flush()\n  }\n\n  private flush() {\n    const callbacks = Array.from(this.callbacks)\n    this.callbacks.clear()\n\n    callbacks.forEach(callback => callback())\n  }\n\n  public onComplete(callback: Function) {\n    this.callbacks.add(callback)\n  }\n}\n\nexport const afterTransaction = (callback: Function) => {\n  if (currentTransaction) {\n    currentTransaction.onComplete(callback)\n    return\n  }\n\n  callback()\n}\n","import { Accessor } from '../Accessor'\nimport { Value } from './Value'\nimport { deepReference, createPath } from './utils'\nimport { merge } from './merge'\nimport { ObjectNode, DataTrait } from '../Node'\nimport { NodeEntry } from './NodeEntry'\nimport { Disposable } from '../utils'\nimport { createEvent } from '@gqless/utils'\nimport { Transaction } from './Transaction'\n\nexport class Cache extends Disposable {\n  public references!: ReturnType<typeof deepReference>\n  public entries = new Map<DataTrait, NodeEntry>()\n\n  public onRootValueChange = createEvent<(rootValue: Value) => void>()\n\n  constructor(node: ObjectNode) {\n    super()\n\n    this.onRootValueChange.listen(() => {\n      if (this.references) this.references.dispose()\n\n      this.references = deepReference(this.rootValue)\n\n      const addToEntries = (value: Value) => {\n        if (!this.entries.has(value.node))\n          this.entries.set(value.node, new NodeEntry(value.node))\n        const graphNode = this.entries.get(value.node)!\n\n        if (graphNode.instances.has(value)) return\n\n        graphNode.instances.add(value)\n      }\n\n      addToEntries(this.rootValue)\n      this.references.onReference.listen(addToEntries)\n      this.references.onUnreference.listen(value => {\n        if (!this.entries.has(value.node)) return\n        const graphNode = this.entries.get(value.node)!\n\n        graphNode.instances.delete(value)\n      })\n    })\n\n    this.rootValue = new Value(node)\n  }\n\n  private _rootValue!: Value\n  public get rootValue() {\n    return this._rootValue\n  }\n  public set rootValue(value: Value) {\n    const prevValue = this._rootValue\n    if (value === prevValue) return\n    this._rootValue = value\n    this.onRootValueChange.emit(value)\n  }\n\n  public merge(accessor: Accessor, data: any) {\n    const transaction = new Transaction()\n\n    transaction.begin()\n    const value = createPath(accessor, data)\n    merge(this, value, data, accessor.extensions)\n    transaction.end()\n  }\n\n  public toJSON(deep = true) {\n    const types: any = {}\n\n    this.entries.forEach(nodeEntry => {\n      types[nodeEntry.node.toString()] =\n        deep === true ? nodeEntry.toJSON() : nodeEntry\n    })\n\n    return {\n      data: deep === true ? this.rootValue.toJSON() : this.rootValue,\n      types,\n    }\n  }\n\n  public dispose() {\n    super.dispose()\n    this.references.dispose()\n  }\n}\n","import { Plugin, PluginMethod } from './Plugin'\n\ntype ComposablePlugin = (plugin: Plugin[]) => Plugin[]\n\nexport class Plugins {\n  private plugins: Plugin[] = []\n\n  public add(...plugins: Plugin[]): void\n  public add(plugin: ComposablePlugin): void\n\n  public add(...args: any[]) {\n    if (args.length === 1 && typeof args[0] === 'function') {\n      const plugin: ComposablePlugin = args[0]\n      this.plugins = plugin(this.plugins)\n    } else {\n      this.plugins.push(...(args as Plugin[]))\n    }\n  }\n\n  public remove(...plugins: Plugin[]) {\n    plugins.forEach(plugin => {\n      const idx = this.plugins.indexOf(plugin)\n\n      if (idx > -1) {\n        this.plugins.splice(idx, 1)\n      }\n    })\n  }\n\n  public all = new Proxy<\n    {\n      [K in keyof Plugin]-?: (\n        ...args: Parameters<PluginMethod<K>>\n      ) => ReturnType<PluginMethod<K>>[]\n    }\n  >({} as any, {\n    get: (_, key: keyof Plugin) => (...args: any[]) => {\n      return this.plugins\n        .filter(plugin => key in plugin)\n        .map(plugin => (plugin[key] as Function)(...args))\n    },\n  })\n\n  public first = new Proxy<\n    {\n      [K in keyof Plugin]-?: (\n        ...args: Parameters<PluginMethod<K>>\n      ) => (\n        isCorrectValue: (value: ReturnType<PluginMethod<K>>) => boolean\n      ) => ReturnType<PluginMethod<K>>\n    }\n  >({} as any, {\n    get: (_, key: keyof Plugin) => (...args: any[]) => (\n      isCorrectValue: (value: any) => boolean\n    ) => {\n      for (const plugin of this.plugins.filter(plugin => key in plugin)) {\n        const value = (plugin[key] as Function)(...args)\n        if (isCorrectValue(value)) return value\n      }\n    },\n  })\n}\n","interface Weight {\n  amount: number\n  count: number\n  priority?: number\n}\n\n/**\n * This algorithmn take a stack of queries, and determines\n * what query each stack should use\n * eg.\n *  [App, Profile] => Profile\n *  [App, Profile, Name] => Profile\n *  [App, Navbar] => App\n *  [App, Profile, Name] => App\n * I'm sure this could be optimized further but it was a pain to get working\n */\nexport const queriesFromStacks = <T extends any>(stacks: T[][]) => {\n  const queryWeights = new Map<T, Weight>()\n\n  const getWeights = (query: T) => {\n    if (queryWeights.has(query)) {\n      return queryWeights.get(query)!\n    }\n\n    const weights: Weight = { amount: 0, count: 0 }\n    queryWeights.set(query, weights)\n    return weights\n  }\n\n  // Iterate stacks and caculate weights\n  stacks.forEach(stack => {\n    stack.forEach((query, i) => {\n      const amount = stack.length - i\n\n      const weights = getWeights(query)\n      weights.count++\n      weights.amount += amount\n    })\n  })\n\n  // Calculate priority\n  const sortedWeights = Array.from(queryWeights).sort(\n    ([, a], [, b]) => b.count - a.count || b.amount - a.amount\n  )\n\n  // Calculate query priorities\n  sortedWeights.forEach(([_, weight], idx) => {\n    if (idx > 0) {\n      const prevWeight = sortedWeights[idx - 1][1]\n\n      if (\n        weight.amount / weight.count ===\n        prevWeight.amount / prevWeight.count\n      ) {\n        weight.priority = prevWeight.priority\n        return\n      }\n    }\n\n    weight.priority = idx\n  })\n\n  const finalQueries = new Set()\n  const queriesCount = new Map()\n\n  const possibleQueries = stacks.map(stack => {\n    let lowestRating: number | undefined\n    let possibleQueries: T[] = []\n\n    const stackSize = stack.length - 1\n    // Iterate in reverse, as the best possible query\n    // is most likely to be at the end\n    for (let i = stackSize; i >= 0; i--) {\n      const query = stack[i]\n      const { priority } = queryWeights.get(query)!\n      const positionRating = stackSize - i\n\n      // If the positionRating is greater\n      // than the lowest recorded rating, then we've already found it\n      if (lowestRating !== undefined && positionRating > lowestRating) break\n\n      const rating = priority! + positionRating\n\n      if (lowestRating === undefined || rating <= lowestRating) {\n        // If it's the same rating, add to possible queries\n        if (lowestRating === undefined || rating === lowestRating) {\n          possibleQueries.push(query)\n        } else {\n          lowestRating = rating\n          possibleQueries = [query]\n        }\n      }\n    }\n\n    if (possibleQueries.length === 1) {\n      finalQueries.add(possibleQueries[0])\n    } else {\n      possibleQueries.forEach(query => {\n        queriesCount.set(query, (queriesCount.get(query) || 0) + 1)\n      })\n    }\n\n    return possibleQueries\n  })\n\n  // Works for 80% of cases, but it depends on the order the entries are passed in\n  return possibleQueries.map(possibleQueries => {\n    let highestCount: number | undefined\n    let chosenQuery: T | undefined\n\n    for (const query of possibleQueries) {\n      if (finalQueries.has(query)) return query\n      const count = queriesCount.get(query)\n\n      if (highestCount === undefined || count > highestCount) {\n        highestCount = count\n        chosenQuery = query\n      }\n    }\n\n    finalQueries.add(chosenQuery)\n\n    return chosenQuery!\n  })\n}\n","export class Query {\n  static instances = new Map<string | undefined, Query>()\n\n  constructor(\n    public name?: string,\n    /**\n     * By default, queries with the same name\n     * will refer to the same query.\n     * Set this to true to disable\n     */\n    unique?: boolean\n  ) {\n    if (Query.instances.has(name)) {\n      if (!unique) return Query.instances.get(name)!\n    } else {\n      Query.instances.set(name, this)\n    }\n  }\n\n  public toString() {\n    return this.name || '(unnamed)'\n  }\n}\n","import { Plugins } from '../Plugin'\nimport { Accessor, NetworkStatus } from '../Accessor'\nimport { Disposable } from '../utils'\nimport { queriesFromStacks } from './queriesFromStacks'\nimport { Query } from './Query'\nimport { createEvent } from '@gqless/utils'\n\nconst defaultQuery = new Query()\n\nexport class Commit extends Disposable {\n  public onActive = createEvent()\n  public onIdle = createEvent()\n\n  public onFetched = createEvent()\n  public accessors = new Map<Accessor, Query[]>()\n\n  constructor(\n    private plugins: Plugins,\n    private stack: Query[],\n    private fetchAccessors: (\n      accessors: Accessor<any>[],\n      queryName?: string\n    ) => any\n  ) {\n    super()\n  }\n\n  public stageUntilValue(accessor: Accessor) {\n    if (!accessor.resolved) return\n    if (accessor.value) return\n\n    const unstage = this.stage(accessor)\n\n    this.addDisposer(\n      accessor.onValueChange.then(unstage),\n      accessor.onResolvedChange.then(resolved => {\n        if (!resolved) unstage()\n      })\n    )\n\n    return unstage\n  }\n\n  public stage(accessor: Accessor, ...queries: Query[]) {\n    const unstage = () => this.unstage(accessor)\n\n    // If the accessor is in this current commit,\n    // or being (re-)fetched from a previous commit, don't re-fetch it\n    if (this.disposed || accessor.status !== NetworkStatus.idle) return unstage\n\n    if (!this.accessors.size) this.onActive.emit()\n\n    accessor.status = accessor.value\n      ? NetworkStatus.updating\n      : NetworkStatus.loading\n\n    this.accessors.set(accessor, [...this.stack, ...queries])\n\n    // If we already have the parent, remove the\n    // parent to narrow down the accessors. This is used when a accessor is created\n    // this could cause issues later, may need to add a recurse field to handle polling etc.\n    if (accessor.parent && this.accessors.has(accessor.parent)) {\n      this.unstage(accessor.parent)\n    }\n\n    return unstage\n  }\n\n  public unstage(accessor: Accessor) {\n    if (this.disposed) return\n\n    // Only if the accessor is in our commits, set it as not fetching\n    // otherwise it could be from a previous commit\n    if (this.accessors.has(accessor)) {\n      accessor.status = NetworkStatus.idle\n    }\n\n    this.accessors.delete(accessor)\n\n    if (!this.accessors.size) this.onIdle.emit()\n  }\n\n  public async fetch() {\n    if (!this.accessors.size) return\n    const accessors = Array.from(this.accessors.keys())\n    const stacks = Array.from(this.accessors.values())\n    const stackQueries = queriesFromStacks(stacks)\n\n    const queries = new Map<Query | undefined, Accessor[]>()\n\n    // Iterate over stacks and convert into query map\n    stackQueries.forEach((query, idx) => {\n      if (query === undefined) {\n        stackQueries[idx] = query = defaultQuery\n      }\n\n      const accessor = accessors[idx]\n\n      if (queries.has(query)) {\n        const accessors = queries.get(query)!\n        accessors.push(accessor)\n        return\n      }\n\n      queries.set(query, [accessor])\n    })\n\n    this.plugins.all.onCommit({ stacks, stackQueries, accessors, queries })\n\n    try {\n      const promises = Array.from(queries)\n        .map(async ([query, accessors]) => {\n          const promise = this.fetchAccessors(accessors, query && query.name)\n\n          try {\n            await promise\n          } finally {\n            accessors.forEach(accessor => {\n              accessor.status = NetworkStatus.idle\n            })\n          }\n        })\n        .filter(Boolean) as Promise<any>[]\n\n      await Promise.all(promises)\n    } catch (e) {\n      console.error(e)\n    }\n\n    this.onFetched.emit()\n  }\n}\n","import { invariant } from '@gqless/utils'\n\nimport { Plugins } from '../Plugin'\nimport { Disposable } from '../utils'\nimport { Commit } from './Commit'\nimport { Query } from './Query'\nimport { Accessor } from '../Accessor'\n\nexport type AccessorFetcher = (accessors: Accessor[], queryName?: string) => any\n\nexport class Scheduler extends Disposable {\n  private timer: any\n\n  public stack: Query[] = []\n  public commit: Commit = undefined!\n\n  constructor(\n    private fetchAccessors: AccessorFetcher,\n    public plugins: Plugins = new Plugins(),\n    public interval = 50 + (__DEV__ ? 100 : 0)\n  ) {\n    super()\n\n    this.startTimer()\n    this.addDisposer(this.clearTimer)\n  }\n\n  public pushStack(...queries: Query[]) {\n    this.stack.push(...queries)\n  }\n\n  public popStack(...queries: Query[]) {\n    for (let i = queries.length - 1; i >= 0; i--) {\n      const query = queries[i]\n      const idx = this.stack.length - 1\n\n      invariant(\n        this.stack[idx] === query,\n        `Scheduler#popStack called with '${query}', but not last in stack [${this.stack.join(\n          ', '\n        )}]`\n      )\n\n      this.stack.splice(idx, 1)\n    }\n  }\n\n  private startTimer() {\n    this.clearTimer()\n\n    // Don't create new Commit, if prev one unused\n    if (!this.commit || this.commit.accessors.size) {\n      if (this.commit) this.commit.dispose()\n\n      this.commit = new Commit(this.plugins, this.stack, this.fetchAccessors)\n    }\n\n    const { commit } = this\n    commit.onActive.then(() => {\n      this.timer = setTimeout(() => {\n        commit.fetch()\n        this.startTimer()\n      }, this.interval)\n\n      commit.onIdle.then(() => {\n        if (commit !== this.commit) return\n\n        // Cancel timer, and wait until commit is active again\n        this.startTimer()\n      })\n    })\n  }\n\n  private clearTimer() {\n    clearTimeout(this.timer)\n  }\n}\n","import { Accessor } from '../Accessor'\nimport { EnumNode, ScalarNode } from '../../Node'\nimport { createEvent } from '@gqless/utils'\nimport { Value } from '../../Cache'\n\n// When value of accessor changes\n// & types are different -> emit\nexport const onDataChange = (accessor: Accessor) => {\n  const onDataChange = createEvent<(prevData: any) => void>()\n\n  let dispose: Function | undefined\n\n  const onValueAssociated = (\n    value: Value | undefined,\n    prevValue: Value | undefined\n  ) => {\n    dispose?.()\n    dispose = undefined\n\n    // Hook for onDataUpdate event\n    const check = () => {\n      const newData = value?.data\n      const prevData = prevValue?.data\n      if (newData === prevData) return\n\n      if (\n        prevData !== undefined ||\n        newData === null ||\n        accessor.node instanceof ScalarNode ||\n        accessor.node instanceof EnumNode\n      ) {\n        onDataChange.emit(prevData)\n      }\n    }\n\n    if (!value) {\n      check()\n      return\n    }\n\n    dispose = value.onChange.listen(check)\n    check()\n  }\n\n  accessor.addDisposer(accessor.onValueChange.listen(onValueAssociated))\n  onValueAssociated(undefined, accessor.value)\n\n  return onDataChange\n}\n","import { Accessor } from '../Accessor'\nimport { Value } from '../../Cache'\n\nexport const syncValue = (\n  accessor: Accessor,\n\n  getFromValue: ((accessorValue: Value) => Value | undefined) | string,\n  withAccessor = accessor.parent\n) => {\n  if (!withAccessor) return\n\n  const isFn = typeof getFromValue === 'function'\n\n  const getValue = (value: Value): Value | undefined => {\n    if (isFn) return (getFromValue as Function)(value)\n\n    return value.get(getFromValue as string)\n  }\n\n  let dispose: Function | undefined\n  const associateValue = () => {\n    if (dispose) {\n      accessor.deleteDiposer(dispose)\n      dispose()\n      dispose = undefined\n    }\n\n    if (withAccessor.value) {\n      accessor.value = getValue(withAccessor.value)\n\n      const onChange = isFn\n        ? withAccessor.value.onChange\n        : withAccessor.value.onSet.filter(k => k === getFromValue)\n\n      dispose = onChange.listen(() => {\n        accessor.value = getValue(withAccessor.value!)\n      })\n      accessor.addDisposer(dispose)\n\n      return\n    }\n\n    accessor.value = undefined\n  }\n\n  accessor.addDisposer(withAccessor.onValueChange.listen(associateValue))\n  associateValue()\n}\n","import { createEvent } from '@gqless/utils'\nimport { Accessor } from './Accessor'\n\nexport type AccessorInterceptor = (accessor: Accessor) => void\nexport const accessorInterceptors = new Set<AccessorInterceptor>()\n\nexport class Interceptor {\n  public listening = false\n\n  public onAccessor = createEvent<AccessorInterceptor>()\n\n  public start() {\n    accessorInterceptors.add(this.onAccessor.emit)\n    this.listening = true\n  }\n\n  public stop() {\n    accessorInterceptors.delete(this.onAccessor.emit)\n    this.listening = false\n  }\n}\n","import { computed, createEvent, invariant, createMemo } from '@gqless/utils'\n\nimport { Cache, Value, afterTransaction } from '../Cache'\nimport {\n  ObjectNode,\n  Abstract,\n  DataTrait,\n  ComputableExtension,\n  ComputedExtension,\n  StaticExtension,\n  DataContext,\n} from '../Node'\nimport { Scheduler, Query } from '../Scheduler'\nimport { Selection, Fragment } from '../Selection'\nimport { Disposable, PathArray, arrayEqual } from '../utils'\nimport { onDataChange } from './utils'\nimport { FragmentAccessor } from '.'\nimport { accessorInterceptors } from '../Interceptor'\n\nexport enum NetworkStatus {\n  idle,\n  loading,\n  updating,\n}\n\nexport const ACCESSOR = Symbol()\n// A query was made with minimal fields on it\n// to save bandwidth - predicted the IDs would match up\n// But returned ID were different, so refetch everything\nconst KEYED_REFETCH = new Query('KeyedRefetch')\n\nconst memoized = createMemo()\n\nexport abstract class Accessor<\n  TSelection extends Selection = Selection,\n  TChildren extends Accessor<Selection, any> = Accessor<Selection, any>\n> extends Disposable {\n  // Ordered by most important -> least\n  public extensions: (StaticExtension | ComputedExtension)[] = []\n  public children: TChildren[] = []\n\n  public scheduler: Scheduler = this.parent\n    ? (this.parent as any).scheduler\n    : undefined!\n  public cache: Cache = this.parent ? (this.parent as any).cache : undefined!\n  // replaces refs of this accessor, with a Fragment\n  // see FragmentAccessor#startResolving\n\n  public fragmentToResolve?: FragmentAccessor\n  protected _data: any\n  protected _status: NetworkStatus = NetworkStatus.idle\n  protected _value: Value | undefined\n  protected _resolved = true\n\n  public onValueChange = createEvent<\n    (value: Value | undefined, prevValue: Value | undefined) => void\n  >()\n  // Equality check only\n  public onDataChange = onDataChange(this)\n  public onResolvedChange = createEvent<(resolved: boolean) => void>()\n  public onStatusChange = createEvent<\n    (status: NetworkStatus, prevStatus: NetworkStatus) => void\n  >()\n  public onInitializeExtensions = createEvent()\n\n  constructor(\n    public readonly parent: Accessor | undefined,\n    public readonly selection: TSelection,\n    public readonly node = selection.node\n  ) {\n    super()\n\n    if (parent) {\n      parent.children.push(this)\n\n      this.addDisposer(\n        // On un-select, dispose of self\n        // used when you do `query.users()`, and an argumentless\n        // selection is created before the function call\n        parent.selection.onUnselect\n          .filter(s => s === selection)\n          .listen(() => this.dispose())\n      )\n    }\n\n    // Update the extensions change when:\n    // - data changes (from null -> object)\n    // - parent extensions change\n    this.addDisposer(\n      this.onDataChange.listen(() => {\n        this.data = undefined\n        this.loadExtensions()\n      }),\n      parent?.onInitializeExtensions.listen(() => {\n        this.loadExtensions()\n      })\n    )\n  }\n\n  public get resolved() {\n    return this._resolved\n  }\n\n  public set resolved(resolved: boolean) {\n    const prevResolved = this._resolved\n    if (prevResolved === resolved) return\n    this._resolved = resolved\n    this.onResolvedChange.emit(resolved)\n  }\n\n  public get data() {\n    if (this.fragmentToResolve) {\n      return this.fragmentToResolve.data\n    }\n\n    if (this._data === undefined) {\n      this.data = this.getData()\n    }\n\n    accessorInterceptors.forEach(intercept => intercept(this))\n\n    return this._data\n  }\n  public set data(data: any) {\n    this._data = data\n  }\n\n  public set status(status: NetworkStatus) {\n    const prevStatus = this._status\n    this._status = status\n    if (prevStatus === status) return\n    this.onStatusChange.emit(status, prevStatus)\n  }\n  public get status() {\n    return this._status\n  }\n\n  public set value(value: Value | undefined) {\n    const prevValue = this._value\n    this._value = value\n    if (prevValue === value) return\n    this.onValueChange.emit(value, prevValue)\n  }\n  public get value() {\n    return this._value\n  }\n\n  protected initializeExtensions() {\n    const addExtensions = (node: DataTrait) => {\n      let extension = node.extension\n      if (!extension) return\n\n      if (extension instanceof ComputableExtension) {\n        extension = new ComputedExtension(extension, this)\n      }\n\n      this.extensions.unshift(extension)\n    }\n\n    if (this.node instanceof Abstract) {\n      for (const node of this.node.implementations) {\n        addExtensions(node)\n      }\n    }\n\n    addExtensions(this.node)\n  }\n\n  protected loadExtensions() {\n    const prevExtensions = this.extensions\n    this.extensions = []\n    this.initializeExtensions()\n\n    if (arrayEqual(prevExtensions, this.extensions)) return\n\n    this.onInitializeExtensions.emit()\n\n    if (!this.extensions.length) return\n\n    // If already a fragment, key fragments should only be added on different types\n    const isTopLevel =\n      !(this instanceof FragmentAccessor) || this.node !== this.parent.node\n\n    if (isTopLevel) {\n      // Add keyFragments\n      this.extensions.forEach(({ fragment }) => {\n        if (!fragment) return\n        if (this.selection === (fragment as any)) return\n\n        this.selection.add(fragment, true)\n      })\n    }\n\n    if (!this.value) {\n      // TODO: Should this be here? or in merge.ts\n      // Cache redirects\n      if (this.cache.entries.has(this.node)) {\n        for (const extension of this.extensions) {\n          const value = extension.redirect(this)\n\n          if (!(value instanceof Value)) continue\n          this.updateValue(value)\n          break\n        }\n      }\n    }\n  }\n\n  // Update the value, by modifying the cache\n  public updateValue(value: Value) {\n    if (value === this.value) return\n\n    invariant(\n      this.parent?.value,\n      `can't update ${this.path} value without parent value`\n    )\n\n    const valueless = new Set(this.children.filter(a => !a.value))\n    this.parent.value.set(this.toString(), value)\n\n    afterTransaction(() => {\n      const accessorWithoutValue = this.children.find(\n        a => !a.value && !valueless.has(a)\n      )\n\n      // If a child accessor is missing a value, then\n      // re-fetch it entirely\n      if (accessorWithoutValue) {\n        this.scheduler.commit.stage(this, KEYED_REFETCH)\n      }\n    })\n  }\n\n  public getData(ctx?: DataContext): any {\n    return undefined\n  }\n\n  public setData(data: any) {\n    // @TODO\n    console.log('set', this.path.toString(), data)\n    this.cache.merge(this, data)\n  }\n\n  public get<TChild extends TChildren | FragmentAccessor>(\n    find:\n      | ((child: TChildren | FragmentAccessor) => boolean)\n      | Selection\n      | string\n      | number\n  ): TChild | undefined {\n    if (typeof find === 'function') {\n      return this.children.find(find) as any\n    }\n\n    if (find instanceof Selection) {\n      const accessor = this.children.find(c => c.selection === find) as any\n      return accessor\n    }\n\n    return this.children.find(c => c.toString() === String(find)) as any\n  }\n\n  public getDefaultFragment(node: ObjectNode) {\n    return memoized.fragment(() => {\n      const fragment = new Fragment(node)\n      this.selectionPath[this.selectionPath.length - 1].add(fragment)\n      return fragment\n    }, [node, ...this.selectionPath])\n  }\n\n  @computed\n  public get selectionPath(): Selection[] {\n    const basePath = this.parent\n      ? this.parent.selectionPath\n      : new PathArray<Selection>()\n    const path =\n      // Remove duplicated selections\n      basePath[basePath.length - 1] === this.selection\n        ? basePath\n        : new PathArray(...basePath, this.selection)\n\n    return path\n  }\n\n  @computed\n  public get path(): Accessor[] {\n    const basePath = this.parent ? this.parent.path : []\n    const path = new PathArray(...basePath, this)\n\n    return path\n  }\n\n  public dispose() {\n    super.dispose()\n\n    if (this.parent) {\n      const idx = this.parent.children.indexOf(this)\n      if (idx !== -1) {\n        this.parent.children.splice(idx, 1)\n      }\n\n      this.scheduler.commit.unstage(this)\n\n      this.scheduler.commit.accessors.forEach((_, accessor) => {\n        // if the accessor begins with this.path\n        for (let i = 0; i < this.path.length; i++) {\n          if (this.path[i] !== accessor.path[i]) return\n        }\n\n        this.scheduler.commit.unstage(accessor)\n      })\n    }\n  }\n}\n","import { FieldSelection } from '../Selection'\nimport { Accessor } from './Accessor'\nimport { syncValue } from './utils'\nimport {\n  ComputableExtension,\n  ComputedExtension,\n  DataTrait,\n  DataContext,\n} from '../Node'\n\nexport class FieldAccessor<\n  TFieldSelection extends FieldSelection<any> = FieldSelection<any>,\n  TChildren extends Accessor = Accessor\n> extends Accessor<TFieldSelection, TChildren> {\n  protected _resolved = this.parent.resolved\n\n  constructor(public parent: Accessor, fieldSelection: TFieldSelection) {\n    super(parent, fieldSelection)\n\n    this.parent.onResolvedChange.listen(resolved => (this.resolved = resolved))\n    syncValue(this, this.toString())\n    this.loadExtensions()\n    this.scheduler.commit.stageUntilValue(this)\n  }\n\n  protected initializeExtensions() {\n    super.initializeExtensions()\n\n    for (let i = this.parent.extensions.length - 1; i >= 0; --i) {\n      let extension = this.parent.extensions[i].childField(this.selection.field)\n      if (!extension) continue\n\n      if (extension instanceof ComputableExtension) {\n        extension = new ComputedExtension(extension, this)\n      }\n\n      this.extensions.unshift(extension)\n    }\n  }\n\n  public getData(ctx?: DataContext): any {\n    return (this.selection.field.ofNode as DataTrait).getData({\n      accessor: this,\n      ...ctx,\n    })\n  }\n\n  public toString() {\n    return this.selection.toString()\n  }\n}\n","import { Fragment } from '../Selection'\nimport { Accessor } from './Accessor'\nimport { syncValue } from './utils'\nimport { DataContext } from '../Node'\n\nexport class FragmentAccessor<\n  TFragment extends Fragment = Fragment,\n  TChildren extends Accessor = Accessor\n> extends Accessor<TFragment, TChildren> {\n  protected _resolved =\n    this.parent!.resolved &&\n    (!this.parent!.value || this.parent!.value.node === this.selection.node)\n\n  constructor(public parent: Accessor, fragment: TFragment) {\n    super(parent, fragment)\n\n    if (fragment.node !== parent.node) {\n      this.parent.onValueChange.listen(value => {\n        this.resolved =\n          this.parent.resolved && (!value || value.node === fragment.node)\n      })\n    }\n\n    // Sync value with parent\n    // (only if the node is the same)\n    syncValue(this, value => (value.node === fragment.node ? value : undefined))\n    this.loadExtensions()\n  }\n\n  /**\n   * Makes the parent temporarily return\n   * this accessor's data\n   */\n  public startResolving() {\n    const originalAccessor = this.parent.fragmentToResolve\n    this.parent.fragmentToResolve = this\n    const resetAccessor = () => {\n      this.parent.fragmentToResolve = originalAccessor\n      removeDisposer()\n    }\n    const removeDisposer = this.addDisposer(resetAccessor)\n    return resetAccessor\n  }\n\n  protected initializeExtensions() {\n    // Copy extensions from parent\n    for (let i = this.parent.extensions.length - 1; i >= 0; --i) {\n      const extension = this.parent.extensions[i]\n      if (extension.node !== this.selection.node) continue\n\n      this.extensions.unshift(extension)\n    }\n  }\n\n  public getData(ctx?: DataContext): any {\n    return this.selection.node.getData({\n      accessor: this,\n      ...ctx,\n    })\n  }\n\n  public toString() {\n    return this.selection.toString()\n  }\n}\n","import {\n  ArrayNode,\n  ComputableExtension,\n  ComputedExtension,\n  DataTrait,\n  DataContext,\n} from '../Node'\nimport { Selection } from '../Selection'\nimport { Accessor } from './Accessor'\nimport { syncValue } from './utils'\n\nexport class IndexAccessor<\n  TSelectionArray extends Selection<ArrayNode<any>> = Selection<ArrayNode<any>>,\n  TChildren extends Accessor = Accessor\n> extends Accessor<TSelectionArray, TChildren> {\n  protected _resolved = this.parent.resolved\n\n  constructor(public parent: Accessor<TSelectionArray>, public index: number) {\n    super(\n      parent,\n      parent.selection,\n      (parent instanceof IndexAccessor\n        ? (parent.node as ArrayNode<any>)\n        : parent.selection.node\n      ).ofNode\n    )\n\n    // Sync from parent status\n    this.addDisposer(\n      this.parent.onStatusChange.listen(status => {\n        this.status = status\n      })\n    )\n\n    this.parent.onResolvedChange.listen(resolved => (this.resolved = resolved))\n    syncValue(this, this.toString())\n    this.loadExtensions()\n    this.scheduler.commit.stageUntilValue(this)\n  }\n\n  protected initializeExtensions() {\n    super.initializeExtensions()\n\n    for (let i = this.parent.extensions.length - 1; i >= 0; --i) {\n      let extension = this.parent.extensions[i].childIndex()\n      if (!extension) continue\n\n      if (extension instanceof ComputableExtension) {\n        extension = new ComputedExtension(extension, this)\n      }\n\n      this.extensions.unshift(extension)\n    }\n  }\n\n  public getData(ctx?: DataContext): any {\n    return (this.selection.node.ofNode as DataTrait).getData({\n      accessor: this,\n      ...ctx,\n    })\n  }\n\n  public toString() {\n    return `${this.index}`\n  }\n}\n","import { Cache, Value } from '../Cache'\nimport { ObjectNode, DataContext } from '../Node'\nimport { Scheduler } from '../Scheduler'\nimport { Selection } from '../Selection'\nimport { Accessor } from './Accessor'\n\nexport class RootAccessor<\n  TSelection extends Selection<ObjectNode> = Selection<ObjectNode>,\n  TChildren extends Accessor = Accessor\n> extends Accessor<TSelection, TChildren> {\n  constructor(\n    selection: TSelection,\n    public scheduler: Scheduler,\n    public cache: Cache = new Cache(selection.node)\n  ) {\n    super(undefined, selection)\n    this.value = cache.rootValue\n\n    this.addDisposer(\n      cache.onRootValueChange.listen(() => (this.value = cache.rootValue))\n    )\n\n    this.loadExtensions()\n  }\n\n  // TODO: This should be replace with a Generic inside accessor\n\n  public getData(ctx?: DataContext): any {\n    return this.selection.node.getData({\n      accessor: this,\n      ...ctx,\n    })\n  }\n\n  public updateValue(value: Value) {\n    this.cache.rootValue = value\n  }\n\n  public toString() {\n    return this.selection.toString()\n  }\n}\n","import { invariant } from '@gqless/utils'\n\nimport { Interceptor } from '../Interceptor'\nimport { ACCESSOR, Accessor } from './Accessor'\n\nlet lastAccessor: Accessor | null\nlet timer: number\n\nconst interceptor = new Interceptor()\ninterceptor.onAccessor.listen(accessor => {\n  lastAccessor = accessor\n\n  clearTimeout(timer)\n  timer = setTimeout(() => {\n    lastAccessor = null\n  })\n})\ninterceptor.start()\n\nexport const getAccessor = (input: any): Accessor => {\n  if (input) {\n    // Attempt to lookup symbol\n    const accessor = input[ACCESSOR]\n    if (accessor) return accessor\n\n    // Support passing accessor directly\n    if (input instanceof Accessor) return input\n  }\n\n  // If a microtask has run since the last referenced\n  // accessor was recorded, then it could be subject\n  // to race conditions\n  invariant(\n    lastAccessor !== null,\n    lastAccessorErrorMessage(\n      `microtask occurred since last accessor was intercepted`\n    )\n  )\n\n  invariant(\n    lastAccessor,\n    lastAccessorErrorMessage(`no accessors have been referenced yet!`)\n  )\n\n  // Check to see if lastAccessor is the same value as\n  // input. If it is, then return it\n  const data = lastAccessor.data\n\n  invariant(\n    data === input,\n    lastAccessorErrorMessage(\n      `'${input}' not equal to '${lastAccessor.path}' (last referenced accessor)`\n    )\n  )\n\n  return lastAccessor\n}\n\nconst lastAccessorErrorMessage = (message: string) =>\n  `Indeterminate accessor! ${message}\\n\\n` +\n  `Ensure calls to getAccessor() *always* dereference data inside the call\\n\\n` +\n  `GOOD : \\`getAccessor(user.name)\\`\\n` +\n  `BAD  : \\`getAccessor(name)\\`\\n`\n","import { ScalarNode, ArrayNode, UnionNode, EnumNode } from '../../'\nimport { lazyGetters } from '@gqless/utils'\nimport { FieldNode } from './FieldNode'\nimport { NodeExtension } from '../../Extension'\nimport { ObjectNode } from '../../ObjectNode'\nimport { InterfaceNode } from '../../InterfaceNode'\n\nexport type IFieldsNodeOptions = {\n  name: string\n  extension?: NodeExtension\n}\n\nexport type UFieldsNode =\n  | ObjectNode\n  | InterfaceNode\n  | UnionNode\n  | ArrayNode\n  | ScalarNode\n  | EnumNode\n\nexport type UFieldsNodeRecord = Record<string, FieldNode<UFieldsNode>>\n\nexport class FieldsNode {\n  public name: string\n  public fields: UFieldsNodeRecord\n\n  constructor(fields: UFieldsNodeRecord, { name }: IFieldsNodeOptions) {\n    this.name = name\n    this.fields = lazyGetters(fields, (fieldName, field) => {\n      // Called when the getter prop is evaluated\n      field.name = fieldName as string\n    })\n  }\n\n  public toString() {\n    return this.name\n  }\n}\n","import { StaticExtension, ComputableExtension, Extension } from '../Extension'\nimport { Accessor } from '../../Accessor'\nimport { Selection } from '../../Selection'\nimport { Value } from '../../Cache'\nimport { accessorInterceptors } from '../../Interceptor'\n\nexport type DataContext<TNode extends DataTrait = DataTrait> = {\n  accessor?: Accessor<Selection<TNode>>\n  selection?: Selection<TNode>\n  extensions?: Extension[]\n  value?: Value\n}\n\nexport const interceptAccessor = (ctx: DataContext) => {\n  if (!ctx.accessor) return\n\n  accessorInterceptors.forEach(intercept => intercept(ctx.accessor!))\n}\n\nexport const getExtensions = (ctx: DataContext) => {\n  if (ctx.extensions) return ctx.extensions\n  if (ctx.accessor) return ctx.accessor.extensions\n\n  return []\n}\n\nexport const getSelection = (ctx: DataContext) => {\n  if (ctx.selection) return ctx.selection\n  if (ctx.accessor) return ctx.accessor.selection\n\n  return\n}\n\nexport const getValue = (ctx: DataContext) => {\n  if (ctx.value) return ctx.value\n  if (ctx.accessor) return ctx.accessor.value\n\n  return\n}\n\nexport interface DataTrait {\n  extension?: StaticExtension | ComputableExtension\n  getData(ctx: DataContext): any\n}\n","import { DataTrait, DataContext, getValue, interceptAccessor } from './traits'\n\nexport type IEnumNodeOptions = {\n  name?: string\n}\n\nexport class EnumNode implements DataTrait {\n  public name?: string\n\n  constructor({ name }: IEnumNodeOptions = {}) {\n    this.name = name\n  }\n\n  public toString() {\n    return this.name || this.constructor.name\n  }\n\n  public getData(ctx: DataContext<EnumNode>): any {\n    interceptAccessor(ctx)\n\n    const value = getValue(ctx)\n    if (!value) return null\n\n    return value.data\n  }\n}\n","import { deepJSONEqual } from '../../utils'\nimport { Value } from '../../Cache'\n\nexport const REDIRECT = Symbol()\nexport const INDEX = Symbol()\n\nexport const GET_KEY = Symbol()\nexport const keyIsValid = (key: unknown) => key != null\nexport const keyIsEqual = (a: unknown, b: unknown) => deepJSONEqual(a, b)\n\nexport type RedirectHelpers = {\n  instances: Set<Value>\n  match(data: any): Value | undefined\n  getByKey<TKey = unknown>(key: TKey): Value | undefined\n}\n\nexport interface ProxyExtension<TData extends object = object> {\n  [key: string]: any\n\n  [REDIRECT]?(\n    args: Record<string, any> | undefined,\n    helpers: RedirectHelpers\n  ): Value | undefined\n\n  [GET_KEY]?(data: TData): any\n}\n\nexport interface ArrayNodeExtension<TArray extends unknown[] = unknown[]>\n  extends ProxyExtension<TArray> {\n  [INDEX]?: NodeExtension<TArray[number]>\n  [GET_KEY]?(data: TArray[number]): any\n}\n\nexport type ObjectNodeExtension<TObject extends {} = {}> = ProxyExtension<\n  TObject\n> &\n  { [K in keyof TObject]?: NodeExtension<TObject[K]> }\n\nexport type ScalarNodeExtension<TData extends unknown = unknown> = TData\n\nexport type UNodeExtension<TData = unknown> = TData extends object\n  ? TData extends any[]\n    ? ArrayNodeExtension<TData>\n    : ObjectNodeExtension<TData>\n  : ScalarNodeExtension<TData>\n\nexport type NodeExtension<TData = any> =\n  | UNodeExtension<TData>\n  | ((data: TData) => UNodeExtension<TData>)\n","import { DataTrait } from '../traits'\nimport { StaticExtension, ComputableExtension } from '.'\nimport { Extension } from './Extension'\n\nexport const createExtension = (\n  node: DataTrait,\n  extension: any,\n  parent?: Extension,\n  keyedBy?: any\n): ComputableExtension | StaticExtension =>\n  new (typeof extension === 'function' ? ComputableExtension : StaticExtension)(\n    parent,\n    node,\n    extension,\n    keyedBy\n  )\n","import { NodeContainer, FieldsNode, FieldNode } from '../abstract'\nimport {\n  ProxyExtension,\n  GET_KEY,\n  ArrayNodeExtension,\n  INDEX,\n  ObjectNodeExtension,\n  REDIRECT,\n} from './NodeExtension'\nimport { PathArray } from '../../utils'\nimport { UFragment, Fragment } from '../../Selection'\nimport { computed, createMemo, invariant } from '@gqless/utils'\nimport { DataTrait } from '../traits'\nimport { ArrayNode } from '../ArrayNode'\nimport { createExtension } from './createExtension'\nimport { Accessor, FieldAccessor } from '../../Accessor'\nimport { Value } from '../../Cache'\n\nconst memo = createMemo()\n\nexport abstract class Extension {\n  public data: any\n\n  constructor(\n    public parent: Extension | undefined,\n    public node: DataTrait,\n    /** (optional) An object used to construct fragmentKey */\n    private fragmentKeyedBy: any = parent ? undefined : node\n  ) {}\n\n  @computed\n  /** A unique key to share instances of a Fragment between extensions */\n  protected get fragmentKey() {\n    return this.path.map(ref => ref.fragmentKeyedBy).filter(Boolean)\n  }\n\n  @computed\n  public get fragment() {\n    const getKey = (this.data as ProxyExtension)?.[GET_KEY]\n    if (!getKey) return\n\n    let node = this.fragmentKey[this.fragmentKey.length - 1]\n    if (node instanceof NodeContainer) {\n      node = node.innerNode as DataTrait\n    }\n\n    // Fragments only work with InterfaceNode / ObjectNode\n    if (!(node instanceof FieldsNode)) return\n\n    return memo.fragment(() => {\n      const fragment = new Fragment(\n        node as UFragment,\n        `Keyed${this.fragmentKey.join('_')}`\n      )\n\n      // Initialize with selections\n      const data = node!.getData({ selection: fragment })\n      getKey(data)\n\n      return fragment\n    }, this.fragmentKey)\n  }\n\n  public get isKeyable() {\n    return !!(this.data as ProxyExtension)?.[GET_KEY]\n  }\n\n  public getKey(value: Value) {\n    const getKey = (this.data as ProxyExtension)?.[GET_KEY]\n    if (!getKey) return\n    const data = value.node.getData({ value })\n    const key = getKey(data)\n\n    return key\n  }\n\n  public redirect(accessor: Accessor) {\n    const redirect = (this.data as ProxyExtension)?.[REDIRECT]\n    if (!redirect) return\n\n    const entry = accessor.cache.entries.get(accessor.node)\n    if (!entry) return\n\n    return redirect(\n      accessor instanceof FieldAccessor\n        ? // @TODO: toJSON everything (could be variables)\n          accessor.selection.args\n        : undefined,\n      {\n        instances: entry.instances,\n        match(data) {\n          return entry.match(data)?.value\n        },\n        getByKey(key) {\n          return entry.getByKey(key)\n        },\n      }\n    )\n  }\n\n  /** Returns a memoized child Extension */\n  public childIndex(): Extension | undefined {\n    return memo.childIndex(() => {\n      invariant(this.node instanceof ArrayNode)\n\n      const indexExtension = (this.data as ArrayNodeExtension)?.[INDEX]\n      if (indexExtension === undefined) return\n      return createExtension(this.node.ofNode, indexExtension, this)\n    }, [this])\n  }\n\n  /** Returns a memoized child Extension, for a given field */\n  public childField(field: FieldNode): Extension | undefined {\n    return memo.childField(() => {\n      invariant(this.node instanceof FieldsNode)\n\n      const fieldExtension = (this.data as ObjectNodeExtension)?.[field.name]\n      if (fieldExtension === undefined) return\n      return createExtension(field.ofNode, fieldExtension, this, field)\n    }, [this, field])\n  }\n\n  public toString() {\n    return this.fragmentKey.toString()\n  }\n\n  @computed\n  public get path(): Extension[] {\n    const basePath = this.parent ? this.parent.path : []\n    const path = new PathArray(...basePath, this)\n\n    return path\n  }\n}\n","import { Extension } from './Extension'\nimport { UNodeExtension } from './NodeExtension'\nimport { DataTrait } from '../traits'\nimport { computed } from '@gqless/utils'\n\nexport class ComputableExtension extends Extension {\n  constructor(\n    parent: Extension | undefined,\n    node: DataTrait,\n    public getData: (data: any) => UNodeExtension,\n    keyedBy?: any\n  ) {\n    super(parent, node, keyedBy)\n  }\n\n  @computed\n  public get data() {\n    // TODO: (Optimization) Could instead return data from an instance of ComputedExtension\n    // if available. ChildField could then return already-computed instances\n    return this.getData(null)\n  }\n}\n","import { Extension } from './Extension'\nimport { UNodeExtension } from './NodeExtension'\nimport { DataTrait } from '../traits'\n\nexport class StaticExtension extends Extension {\n  constructor(\n    parent: Extension | undefined,\n    node: DataTrait,\n    public data: UNodeExtension,\n    keyedBy?: any\n  ) {\n    super(parent, node, keyedBy)\n  }\n}\n","import { Extension } from './Extension'\nimport { Accessor } from '../../Accessor'\nimport { ComputableExtension } from './ComputableExtension'\nimport { computed } from '@gqless/utils'\nimport { ScalarNode } from '../ScalarNode'\n\nexport class ComputedExtension extends Extension {\n  constructor(parent: ComputableExtension, public accessor: Accessor) {\n    super(parent, parent.node)\n  }\n\n  @computed\n  public get data(): any {\n    const data =\n      this.accessor.node instanceof ScalarNode\n        ? this.accessor.getData({\n            // Remove extensions, to prevent an infinite loop\n            extensions: [],\n          })\n        : this.accessor.data\n\n    return (this.parent as ComputableExtension).getData(data)\n  }\n}\n","import { Value } from '../../Cache'\n\nexport class Matchable {\n  public match(value: Value, data: any): Value | null | void {\n    // Direct equal\n    if (value.data === data) return value\n\n    // Support for callback-style\n    if (typeof data === 'function') {\n      const isAMatch = data(value.data)\n\n      return isAMatch ? (isAMatch instanceof Value ? isAMatch : value) : null\n    }\n    // Can only be a match with null\n    // if both equal null\n    if (value.data === null || data === null) return null\n  }\n}\n","import {\n  NodeExtension,\n  StaticExtension,\n  ComputableExtension,\n  createExtension,\n  ComputedExtension,\n} from './Extension'\nimport { Matchable } from './abstract/Matchable'\nimport { Value } from '../Cache'\nimport {\n  DataTrait,\n  DataContext,\n  getExtensions,\n  getValue,\n  interceptAccessor,\n} from './traits'\n\nexport type IScalarNodeOptions = {\n  name?: string\n  extension?: NodeExtension\n}\n\nexport class ScalarNode extends Matchable implements DataTrait {\n  public extension?: StaticExtension | ComputableExtension\n  public name?: string\n\n  constructor({ name, extension }: IScalarNodeOptions = {}) {\n    super()\n\n    this.name = name\n\n    if (extension) {\n      this.extension = createExtension(this, extension)\n    }\n  }\n\n  public match(value: Value, data: any) {\n    const result = super.match(value, data)\n    if (result !== undefined) return result\n\n    if (data instanceof RegExp) {\n      const input = String(value.data)\n      return input.match(data) ? value : undefined\n    }\n\n    return\n  }\n\n  public toString() {\n    return this.name || this.constructor.name\n  }\n\n  public getData(ctx: DataContext) {\n    interceptAccessor(ctx)\n\n    const extensions = getExtensions(ctx)\n    const value = getValue(ctx)\n\n    const extension = extensions[0]\n    if (extension) {\n      return extension.data\n    }\n\n    if (!value) return null\n    return value.data\n  }\n}\n","import { computed } from '@gqless/utils'\n\nexport class NodeContainer<TNode extends object> {\n  constructor(public ofNode: TNode, public nullable = false) {}\n\n  @computed\n  public get innerNode(): object {\n    if (this.ofNode instanceof NodeContainer) {\n      return this.ofNode.innerNode\n    }\n\n    return this.ofNode\n  }\n}\n","import { invariant } from '@gqless/utils'\nimport { deepJSONEqual } from '../../../utils'\nimport { Arguments } from '../../Arguments'\nimport { FieldAccessor } from '../../../Accessor'\nimport { FieldSelection } from '../../../Selection'\nimport { EnumNode } from '../../EnumNode'\nimport { ScalarNode } from '../../ScalarNode'\nimport { NodeContainer } from '../NodeContainer'\nimport { FieldsNode } from './FieldsNode'\nimport { Variable } from '../../../Variable'\nimport {\n  DataTrait,\n  DataContext,\n  getSelection,\n  interceptAccessor,\n} from '../../traits'\n\nexport class FieldNode<TNode extends DataTrait = DataTrait>\n  extends NodeContainer<TNode>\n  implements DataTrait {\n  // This is set inside FieldsNode\n  public name: string = ''\n\n  constructor(node: TNode, public args?: Arguments, nullable?: boolean) {\n    super(node, nullable)\n  }\n\n  public get uncallable() {\n    return !(\n      this.args &&\n      (this.args.required ||\n        this.ofNode instanceof ScalarNode ||\n        this.ofNode instanceof EnumNode)\n    )\n  }\n\n  public getSelection(\n    ctx: DataContext,\n    args?: Record<string, any>\n  ): FieldSelection<TNode> {\n    interceptAccessor(ctx)\n\n    const parentSelection = getSelection(ctx)\n\n    let selection = parentSelection?.get<FieldSelection<TNode>>(selection => {\n      if (!(selection instanceof FieldSelection)) return false\n\n      return (\n        selection.field.name === this.name &&\n        deepJSONEqual(selection.args, args, (a, b) => {\n          // If either is a variable they need to be equal\n          if (a instanceof Variable || b instanceof Variable) return a === b\n\n          return undefined\n        })\n      )\n    })\n\n    if (selection) return selection\n\n    selection = new FieldSelection(this, args)\n    parentSelection?.add(selection)\n\n    return selection\n  }\n\n  public getData(ctx: DataContext<FieldsNode & DataTrait>) {\n    const getData = (selection: FieldSelection<TNode>): any => {\n      if (ctx.accessor) {\n        const accessor =\n          ctx.accessor.get(selection) ||\n          new FieldAccessor(ctx.accessor, selection)\n\n        return accessor.data\n      }\n\n      return this.ofNode.getData({\n        selection,\n        value: ctx.value?.get(selection.toString()),\n        extensions: [], // TODO\n      })\n    }\n\n    const argsFn = (args: any) => {\n      const parsedArgs = args && (Object.keys(args).length ? args : undefined)\n      return getData(this.getSelection(ctx, parsedArgs))\n    }\n\n    if (!this.uncallable) return argsFn\n\n    let selection: FieldSelection<TNode> | undefined\n    let data: any\n    const argumentlessData = () => {\n      if (selection) return data\n      selection = this.getSelection(ctx)\n      data = getData(selection)\n      return data\n    }\n\n    if (this.args) {\n      return new Proxy(argsFn, {\n        get: (_, prop) => {\n          const data = argumentlessData()\n\n          invariant(\n            data,\n            `Cannot read property '${String(\n              prop\n            )}' on null [${selection}]\\n\\n` +\n              `You should check for null using \\`${selection}() && ${selection}().${String(\n                prop\n              )}\\``\n          )\n\n          const result = data[prop]\n\n          if (typeof result === 'function') {\n            return result.bind(data)\n          }\n\n          return result\n        },\n        set: (_, prop, value) => {\n          const data = argumentlessData()\n\n          invariant(\n            data,\n            `Cannot set property '${String(prop)}' on null [${selection}]\\n\\n` +\n              `You should check for null using \\`${selection}() && ${selection}().${String(\n                prop\n              )}\\``\n          )\n\n          data[prop] = value\n\n          return true\n        },\n      })\n    }\n\n    return argumentlessData()\n  }\n\n  public toString() {\n    return this.name\n  }\n}\n","import { ObjectNode } from '../ObjectNode'\nimport { ACCESSOR, FragmentAccessor } from '../../Accessor'\nimport { invariant } from '@gqless/utils'\nimport {\n  DataTrait,\n  DataContext,\n  getValue,\n  getExtensions,\n  interceptAccessor,\n} from '../traits'\n\nexport const getAbstractImplementation = (node: object, typename: string) => {\n  if (node instanceof Abstract && typename) {\n    const implementation = node.implementations.find(\n      i => i.toString() === typename\n    )\n    invariant(implementation, `'${typename}' is not a valid subtype of ${node}`)\n    return implementation\n  }\n\n  return\n}\n\nexport class Abstract<TNode extends ObjectNode = ObjectNode>\n  implements DataTrait {\n  private abstractProxy: any\n  protected abstractCtx: any\n\n  constructor(public implementations: TNode[]) {}\n\n  public getData(ctx: DataContext) {\n    interceptAccessor(ctx)\n\n    const value = getValue(ctx)\n\n    // If the value is nulled, return null\n    if (value) {\n      if (value.data === null) return null\n\n      if (ctx.accessor) {\n        const fragment = ctx.accessor.getDefaultFragment(\n          value.node as ObjectNode\n        )\n        const fragmentAccessor =\n          ctx.accessor.get(fragment) ||\n          new FragmentAccessor(ctx.accessor, fragment)\n\n        return fragmentAccessor.data\n      }\n    }\n\n    return new Proxy(\n      {},\n      {\n        get: (_, prop: any) => {\n          const fragment = ctx.accessor?.fragmentToResolve\n          if (fragment) return fragment.data?.[prop]\n\n          if (prop === ACCESSOR) return ctx.accessor\n\n          if (prop === '__typename') {\n            return getValue(ctx)?.node.toString()\n          }\n\n          if (prop === 'toString') return () => this.toString()\n\n          // fallback to extensions\n          for (const extension of getExtensions(ctx)) {\n            if (prop in extension.data) return extension.data[prop]\n          }\n        },\n\n        set: (_, prop: any, value: any) => {\n          const fragment = ctx.accessor?.fragmentToResolve\n          if (fragment) {\n            const { data } = fragment\n            if (data) data[prop] = value\n            return true\n          }\n\n          // else set it on the first extension with the property\n          for (const extension of getExtensions(ctx)) {\n            if (prop in extension) {\n              extension.data[prop] = value\n              return true\n            }\n          }\n\n          return true\n        },\n      }\n    )\n  }\n\n  public toString() {\n    return this.implementations.join('|')\n  }\n}\n","import { Generic, Mix } from 'mix-classes'\n\nimport { IndexAccessor } from '../Accessor'\nimport { ACCESSOR } from '../Accessor'\nimport { NodeContainer, Matchable } from './abstract'\nimport { Value } from '../Cache'\nimport { ArrayNodeExtension } from './Extension'\nimport { createMemo } from '@gqless/utils'\nimport {\n  DataTrait,\n  DataContext,\n  getValue,\n  getExtensions,\n  interceptAccessor,\n} from './traits'\n\nexport interface ArrayNode<TNode extends object = object>\n  extends NodeContainer<TNode> {}\n\nconst memo = createMemo()\n\nexport class ArrayNode<TNode> extends Mix(Generic(NodeContainer), Matchable)\n  implements DataTrait {\n  constructor(ofNode: TNode, nullable?: boolean) {\n    // memoize instances of ArrayNode\n    const existingNode = memo<ArrayNode<TNode>>([ofNode, nullable])\n    if (existingNode) return existingNode\n\n    super([ofNode, nullable])\n\n    memo(() => this, [ofNode, nullable])\n  }\n\n  public match(value: Value, data: any) {\n    const result = super.match(value, data)\n    if (result !== undefined) return result\n\n    // Whole array match\n    if (Array.isArray(data)) {\n      if (data.length !== (value.data! as []).length) return\n\n      const badMatch = data.find((match, i) => {\n        const indexValue = value.get(i)\n        if (!indexValue) return true\n\n        if (!(indexValue.node instanceof Matchable)) return\n\n        return !indexValue.node.match(indexValue, data[i])\n      })\n      if (badMatch) return\n\n      return value\n    }\n\n    // Array index match\n    const innerNode = (value.node as ArrayNode).innerNode\n    if (!(innerNode instanceof Matchable)) return\n\n    for (const indexValue of value.data as []) {\n      const match = innerNode.match(indexValue, data)\n      if (match) return match\n    }\n\n    return\n  }\n\n  public getData(ctx: DataContext<ArrayNode<TNode>>) {\n    interceptAccessor(ctx)\n\n    const proxy: any[] = new Proxy([] as any[], {\n      get: (target, prop: any) => {\n        if (prop === ACCESSOR) return ctx.accessor\n        const arr = getValue(ctx)?.data as any[] | undefined\n\n        if (prop === 'length') {\n          return arr?.length ?? 1\n        }\n\n        if (prop === 'toString') {\n          return () => this.toString()\n        }\n\n        if (typeof prop === 'string') {\n          const index = +prop\n\n          if (!isNaN(index)) {\n            // If the array is fetched, make sure index exists\n            if (arr && index >= arr!.length) return undefined\n\n            if (ctx.accessor) {\n              const accessor: IndexAccessor =\n                ctx.accessor.get(index) ||\n                new IndexAccessor(ctx.accessor, index)\n\n              return accessor.data\n            }\n\n            return ((this.ofNode as any) as DataTrait).getData({\n              value: ctx.value?.get(index),\n              selection: ctx.selection,\n              extensions: [], // todo\n            })\n          }\n        }\n\n        // fallback to extensions\n        for (const extension of getExtensions(ctx)) {\n          if (prop in extension.data)\n            return (extension.data as ArrayNodeExtension)[prop]\n        }\n\n        const arrayProperty = target[prop]\n        if (typeof arrayProperty === 'function') {\n          return arrayProperty.bind(proxy)\n        }\n\n        return arrayProperty\n      },\n      has: (target, prop) => {\n        const value = getValue(ctx)\n        if (value) {\n          return value.data ? prop in (value.data as any[]) : false\n        }\n\n        // todo read value\n        if (typeof prop === 'string' && !isNaN(+prop)) {\n          return true\n        }\n\n        return prop in target\n      },\n    })\n\n    return proxy\n  }\n\n  public toString() {\n    return `[${this.ofNode}${this.nullable ? '' : '!'}]`\n  }\n}\n","import { Generic, Mix, getMixin } from 'mix-classes'\n\nimport {\n  FieldsNode,\n  IFieldsNodeOptions,\n  Abstract,\n  UFieldsNodeRecord,\n} from './abstract'\nimport {\n  NodeExtension,\n  StaticExtension,\n  ComputableExtension,\n  createExtension,\n} from './Extension'\nimport { ObjectNode } from './ObjectNode'\nimport { FieldAccessor } from '../Accessor'\nimport { DataTrait, DataContext } from './traits'\n\nexport type IInterfaceNodeOptions = IFieldsNodeOptions & {\n  extension?: NodeExtension\n}\n\nexport interface InterfaceNode<TImplementation extends ObjectNode = ObjectNode>\n  extends Abstract<TImplementation> {}\n\nexport class InterfaceNode<TImplementation>\n  extends Mix(FieldsNode, Generic(Abstract))\n  implements DataTrait {\n  public extension?: StaticExtension | ComputableExtension\n\n  constructor(\n    fields: UFieldsNodeRecord,\n    implementations: TImplementation[],\n    options: IInterfaceNodeOptions\n  ) {\n    super([fields, options], [implementations])\n\n    if (options.extension) {\n      this.extension = createExtension(this, options.extension)\n    }\n  }\n\n  public getData(ctx: DataContext): any {\n    // @ts-ignore typescript limitation of mix-classes\n    const data = super.getData(ctx)\n    if (!data) return data\n    return new Proxy(data, {\n      get: (_, prop: any) => {\n        const fragment = ctx.accessor?.fragmentToResolve\n        if (fragment) return fragment.data?.[prop]\n\n        // If the prop exists in this interface,\n        // return directly from interface\n        if (this.fields.hasOwnProperty(prop)) {\n          const field = this.fields[prop]\n\n          // if (field.args) {\n          //   return (args: any) => {\n          //     // forEach key in args\n\n          //     // if key in an implementation, create implementation accessor\n\n          //     // create interface accessor\n          //   }\n          // }\n\n          return field.getData(ctx as any)\n        }\n\n        // if prop only in one implementation\n\n        // else throw an error if it doesn't satisfy conditions\n\n        return data[prop]\n      },\n\n      set: (_, prop: string, value) => {\n        const fragment = ctx.accessor?.fragmentToResolve\n        if (fragment) {\n          const { data } = fragment\n          if (data) data[prop] = value\n          return true\n        }\n\n        if (prop === '__typename') return true\n\n        /**\n         * If setting a field, create a new accessor and set data\n         */\n        if (this.fields.hasOwnProperty(prop)) {\n          if (!ctx.accessor) return true\n\n          const field = this.fields[prop]\n          const selection = field.getSelection(ctx)\n\n          const fieldAccessor =\n            ctx.accessor.get(selection) ||\n            new FieldAccessor(ctx.accessor, selection)\n\n          fieldAccessor.setData(data)\n\n          return true\n        }\n\n        data[prop] = value\n\n        return true\n      },\n    })\n  }\n\n  public toString() {\n    return getMixin(this, FieldsNode)!.toString()\n  }\n}\n","import { Mix } from 'mix-classes'\nimport { FieldAccessor } from '../Accessor'\nimport { ACCESSOR } from '../Accessor/Accessor'\nimport {\n  FieldNode,\n  FieldsNode,\n  IFieldsNodeOptions,\n  UFieldsNodeRecord,\n  Matchable,\n} from './abstract'\nimport { ScalarNode } from './ScalarNode'\nimport { Value } from '../Cache'\nimport {\n  ComputableExtension,\n  StaticExtension,\n  createExtension,\n} from './Extension'\nimport { DataTrait, DataContext, getValue, getExtensions } from './traits'\n\nexport type IObjectNodeOptions = IFieldsNodeOptions\n\nconst TYPENAME_NODE = new ScalarNode()\n\nexport class ObjectNode extends Mix(FieldsNode, Matchable)\n  implements DataTrait {\n  public extension?: ComputableExtension | StaticExtension\n\n  constructor(fields: UFieldsNodeRecord, options: IObjectNodeOptions) {\n    fields.__typename = new FieldNode(TYPENAME_NODE)\n    super([fields as any, options])\n\n    if (options.extension) {\n      this.extension = createExtension(this, options.extension)\n    }\n  }\n\n  public match(value: Value, data: any) {\n    const result = super.match(value, data)\n    if (result !== undefined) return result\n\n    let matches = 0\n\n    for (const key in data) {\n      if (!this.fields.hasOwnProperty(key)) continue\n      const field = this.fields[key]\n      if (!(field.ofNode instanceof Matchable)) continue\n\n      const keyValue = value.get(key)\n      const keyData = data[key]\n\n      if (!keyValue) continue\n\n      const isMatch = field.ofNode.match(keyValue, keyData)\n      if (!isMatch) return\n      matches++\n    }\n\n    return matches ? value : undefined\n  }\n\n  public getData(ctx: DataContext): any {\n    const value = getValue(ctx)\n\n    if (value?.data === null) return null\n\n    return new Proxy({} as any, {\n      get: (_, prop: any) => {\n        const fragment = ctx.accessor?.fragmentToResolve\n        if (fragment) return fragment.data?.[prop]\n\n        if (prop === ACCESSOR) return ctx.accessor\n        // Statically resolve __typename\n        if (prop === '__typename') return this.name\n\n        // check fields first\n        if (this.fields.hasOwnProperty(prop)) {\n          const field = this.fields[prop]\n\n          return field.getData(ctx as any)\n        }\n\n        if (prop === 'toString') return () => this.toString()\n\n        // fallback to extensions\n\n        for (const extension of getExtensions(ctx)) {\n          if (prop in extension.data) return extension.data[prop]\n        }\n      },\n\n      set: (_, prop: string, value) => {\n        const fragment = ctx.accessor?.fragmentToResolve\n        if (fragment) {\n          const { data } = fragment\n          if (data) data[prop] = value\n          return true\n        }\n\n        if (prop === '__typename') return true\n\n        /**\n         * If setting a field, create a new accessor and set data\n         */\n        if (this.fields.hasOwnProperty(prop)) {\n          if (!ctx.accessor) return true\n\n          const field = this.fields[prop]\n          const selection = field.getSelection(ctx)\n\n          const fieldAccessor =\n            ctx.accessor.get(selection) ||\n            new FieldAccessor(ctx.accessor, selection)\n\n          fieldAccessor.setData(value)\n\n          return true\n        }\n\n        /**\n         * else set it on the first extension with the property\n         */\n        for (const extension of getExtensions(ctx)) {\n          if (prop in extension.data) {\n            extension.data[prop] = value\n            return true\n          }\n        }\n\n        return true\n      },\n    })\n  }\n}\n","import { lazyGetters } from '@gqless/utils'\n\nimport { ArrayNode, InputNode, ScalarNode } from '../'\nimport { EnumNode } from '../EnumNode'\nimport { ArgumentsField } from './ArgumentsField'\n\nexport type UArguments =\n  | ScalarNode\n  | EnumNode\n  | ArrayNode<any>\n  | ArgumentsField\n  | InputNode\n\ntype UArgumentsRecord = Record<string, ArgumentsField>\n\nexport class Arguments {\n  public inputs: UArgumentsRecord\n\n  constructor(inputs: UArgumentsRecord, public required = false) {\n    this.inputs = lazyGetters(inputs, (fieldName, field) => {\n      // Called when the getter prop is evaluated\n      field.name = fieldName as string\n    })\n  }\n}\n","import { NodeContainer } from '../abstract'\nimport { UArguments } from './Arguments'\n\nexport class ArgumentsField extends NodeContainer<UArguments> {\n  // This is set inside Arguments\n  public name: string = ''\n\n  constructor(node: UArguments, nullable?: boolean) {\n    super(node, nullable)\n  }\n}\n","import { RootAccessor, Accessor } from './Accessor'\nimport { Cache } from './Cache'\nimport { ObjectNode } from './Node'\nimport { Plugins } from './Plugin'\nimport { Scheduler } from './Scheduler'\nimport { Selection } from './Selection'\nimport { Disposable } from './utils'\nimport { buildQuery, Formatter } from './QueryBuilder'\n\nexport type QueryResponse<Data = any> = { data: Data; errors: any }\n\nexport type QueryFetcher = (\n  query: string,\n  variables?: Record<string, any>\n) => Promise<QueryResponse> | QueryResponse\n\nexport type ClientOptions = {\n  prettifyQueries?: boolean\n}\n\n// @ts-ignore\nexport class Client<TData = any> extends Disposable {\n  public plugins = new Plugins()\n  public formatter: Formatter\n\n  public scheduler = new Scheduler(\n    (accessors, name) => this.fetchAccessors(accessors, name)!,\n    this.plugins\n  )\n  public cache = new Cache(this.node)\n\n  public selection = new Selection(this.node)\n  public accessor = new RootAccessor(this.selection, this.scheduler, this.cache)\n\n  public query = this.accessor.data as TData\n\n  constructor(\n    protected node: ObjectNode,\n    protected fetchQuery: QueryFetcher,\n    { prettifyQueries }: ClientOptions = {}\n  ) {\n    super()\n\n    this.formatter = new Formatter({\n      prettify: prettifyQueries,\n      fragments: 'auto',\n      variables: true,\n    })\n    this.selection.onSelect.listen(selection => {\n      this.plugins.all.onSelect(selection)\n    })\n\n    this.selection.onUnselect.listen(selection => {\n      this.plugins.all.onUnselect(selection)\n    })\n  }\n\n  protected fetchAccessors(accessors: Accessor[], queryName?: string) {\n    const result = buildQuery(\n      this.formatter,\n      queryName,\n      ...accessors.map(accessor => accessor.selectionPath)\n    )\n\n    if (!result) return\n\n    const responsePromise = (async () => {\n      const response = await this.fetchQuery(result.query, result.variables)\n      result.rootTree.resolveAliases(response.data)\n      this.cache.merge(this.accessor, response.data)\n      return response\n    })()\n\n    this.plugins.all.onFetch(\n      accessors,\n      responsePromise,\n      result.variables,\n      result.query,\n      queryName\n    )\n\n    return responsePromise\n  }\n\n  public dispose() {\n    super.dispose()\n    this.scheduler.dispose()\n\n    this.plugins.all.dispose()\n  }\n}\n","import { lazyGetters } from '@gqless/utils'\n\nimport { ArrayNode } from '../ArrayNode'\nimport { EnumNode } from '../EnumNode'\nimport { ScalarNode } from '../ScalarNode'\nimport { InputNodeField } from './InputNodeField'\n\nexport type UInputNode = ScalarNode | ArrayNode | InputNode | EnumNode\n\ntype UInputNodeRecord = Record<string, InputNodeField>\n\nexport type IInputNodeOptions = {\n  name: string\n}\n\nexport class InputNode {\n  public name?: string\n  public inputs: UInputNodeRecord\n\n  constructor(inputs: UInputNodeRecord, { name }: IInputNodeOptions) {\n    this.name = name\n    this.inputs = lazyGetters(inputs)\n  }\n\n  public toString() {\n    return this.name || this.constructor.name\n  }\n}\n","import { NodeContainer } from '../abstract'\nimport { UInputNode } from './InputNode'\n\nexport class InputNodeField extends NodeContainer<UInputNode> {\n  constructor(node: UInputNode, nullable?: boolean) {\n    super(node, nullable)\n  }\n}\n","import { Accessor, getAccessor } from '../Accessor'\nimport { Query } from '../Scheduler'\n\n// @TODO selection.onStatusChange should reset the timer\n// if it's been called from outside\n\nexport class Poller {\n  private accessor: Accessor\n\n  private timer?: number\n  private unstage?: Function\n\n  public polling = false\n\n  constructor(data: any, public interval: number, public stack?: Query[]) {\n    this.accessor = getAccessor(data)\n  }\n\n  public updateInterval(interval: number) {\n    if (this.interval === interval) return\n    this.interval = interval\n\n    this.resetTimer()\n  }\n\n  /**\n   * Polls the selection, scheduling a new poll\n   * only after it's been fetched\n   */\n  private async poll() {\n    this.unstage = this.accessor.scheduler.commit.stage(\n      this.accessor,\n      ...(this.stack || [])\n    )\n\n    // Wait until it's been fetched, before polling again\n    await this.accessor.onStatusChange\n\n    this.unstage = undefined\n\n    // If we're still polling after we've fetched\n    // the selection, then poll again\n    if (this.polling) {\n      this.pollAfterInterval()\n    }\n  }\n\n  private pollAfterInterval() {\n    this.timer = setTimeout(() => this.poll(), this.interval)\n  }\n\n  public resetTimer() {\n    if (this.polling) this.toggle(true)\n  }\n\n  public toggle(poll = !this.polling) {\n    this.polling = poll\n\n    this.unstage?.()\n    clearTimeout(this.timer)\n\n    if (!poll) return\n\n    this.pollAfterInterval()\n  }\n}\n","import { Abstract } from './abstract'\nimport { ObjectNode } from './ObjectNode'\n\nexport class UnionNode<TNode extends ObjectNode = ObjectNode> extends Abstract {\n  constructor(ofNodes: TNode[]) {\n    super(ofNodes)\n  }\n}\n","import { Fragment } from '../Selection'\nimport { getAccessor, FragmentAccessor } from '../Accessor'\n\n/**\n * Attaches a fragment to an accessor, and returns the data\n *\n * @example\n * fragmentOn(query.me, new Fragment(schema.User))\n */\nexport const fragmentOn = (data: any, fragment: Fragment) => {\n  const accessor = getAccessor(data)\n\n  let fragmentAccessor = (accessor instanceof FragmentAccessor\n    ? accessor.parent\n    : accessor\n  ).get(fragment)\n\n  if (!fragmentAccessor) {\n    accessor.selection.add(fragment)\n    fragmentAccessor = new FragmentAccessor(accessor, fragment)\n  }\n\n  return fragmentAccessor.data\n}\n","import { getAccessor } from '../Accessor'\n\n/**\n * Updates an accessor, with a compatible Value matching a pattern\n *\n * @example\n * // true for correct matches\n * matchUpdate(query.me, { id: 'Bob' })\n * // => true\n *\n * // returns false for bad matches\n * matchUpdate(query.me, { id: 'no' })\n * // => false\n */\nexport const matchUpdate = (data: any, pattern: any) => {\n  const accessor = getAccessor(data)\n  const entry = accessor.cache.entries.get(accessor.node)\n  if (!entry) return false\n\n  const match = entry.match(pattern)\n  if (!match) return false\n\n  accessor.updateValue(match.value)\n  return true\n}\n","import { invariant } from '@gqless/utils'\n\n/**\n * Preload a function / React component\n *\n * @example\n * // Preload a React Component\n * preload(UserComponent, { user })\n *\n * // Preload a normal function\n * preload(getFullName, user)\n */\nexport const preload = <T extends (...args: any[]) => any>(\n  _func: T,\n  ..._args: T extends (...args: infer U) => any\n    ? Partial<{ [K in keyof U]: Partial<U[K]> }>\n    : never\n) => {\n  // This function will be replaced by babel plugin\n  invariant(false as true, `babel-plugin-gqless is required for preloading`)\n}\n","import { getAccessor } from '../Accessor'\n\n/**\n * Refetches an accessor\n *\n * @example\n * refetch(query.me)\n */\nexport const refetch = (data: any) => {\n  const accessor = getAccessor(data)\n  accessor.scheduler.commit.stage(accessor)\n}\n","import { getAccessor, NetworkStatus, Accessor } from '../Accessor'\nimport { Interceptor } from '../Interceptor'\n\ninterface ResolvedOptions {\n  waitForUpdate?: boolean\n  refetch?: boolean\n}\n\n/**\n * Waits for an accessor / function to be fully resolved,\n * and returns the final value\n *\n * @example\n * const name = await resolved(query.me.name)\n * console.log(name)\n *\n * @example\n * const data = await resolved(() => ({ name: query.me.name }))\n * console.log(data.name)\n *\n * @example\n * await resolved(query.me.name)\n * console.log(query.me.name)\n */\nexport function resolved<T>(\n  data: T,\n  options?: ResolvedOptions\n): Promise<T extends (...args: any[]) => infer U ? U : T> {\n  const isResolved = (accessor: Accessor) =>\n    options?.waitForUpdate || false\n      ? accessor.status === NetworkStatus.idle\n      : accessor.status !== NetworkStatus.loading\n\n  let accessor: Accessor\n  try {\n    accessor = getAccessor(data)\n    if (options?.refetch) accessor.scheduler.commit.stage(accessor)\n  } catch (err) {\n    if (typeof data !== 'function') throw err\n\n    const interceptor = new Interceptor()\n    const nonIdleAccessors = new Set<Accessor>()\n\n    interceptor.onAccessor.listen(acc => {\n      if (nonIdleAccessors.has(acc)) return\n      nonIdleAccessors.add(acc)\n      if (options?.refetch) acc.scheduler.commit.stage(acc)\n    })\n\n    interceptor.start()\n    try {\n      var result = data()\n    } finally {\n      interceptor.stop()\n    }\n\n    return new Promise((resolve, reject) => {\n      nonIdleAccessors.forEach(acc => {\n        if (isResolved(acc)) {\n          nonIdleAccessors.delete(acc)\n          return\n        }\n\n        const dispose = acc.onStatusChange.listen(() => {\n          if (!isResolved(acc)) return\n          dispose()\n\n          nonIdleAccessors.delete(acc)\n          if (nonIdleAccessors.size) return\n\n          try {\n            const finalResult = data()\n            resolve(finalResult)\n          } catch (e) {\n            reject(e)\n          }\n        })\n      })\n\n      if (!nonIdleAccessors.size) {\n        resolve(result)\n      }\n    })\n  }\n\n  if (isResolved(accessor)) {\n    return Promise.resolve(data) as any\n  }\n\n  return new Promise<any>(resolve => {\n    // TODO: Support for promise reject\n    accessor.onStatusChange.listen(() => {\n      if (isResolved(accessor)) resolve(accessor.data)\n    })\n  })\n}\n","import { getAccessor } from '../Accessor'\n\n/**\n * Updates the Value for an accessor\n *\n * @example\n * // Update a scalar\n * update(query.me.name, 'bob')\n *\n * // Update an object\n * update(query, { me: { name: 'bob' } })\n */\nexport const update = (data: any, newData: any) => {\n  const accessor = getAccessor(data)\n\n  return accessor.setData(newData)\n}\n"],"names":["id","Value","constructor","node","data","ArrayNode","Map","createEvent","onSet","listen","key","value","this","references","has","set","Set","referencedKeys","get","size","onReference","emit","add","filter","k","then","delete","onUnreference","_data","prevData","Object","entries","forEach","String","onChange","hasOwnProperty","_this$data","toJSON","deep","map","ObjectNode","obj","__typename","name","deepReference","rootValue","disposers","valueReferences","WeakMap","count","watchAndEmit","parentValue","watcherDisposers","handleReference","unrefFromParent","v","dispose","ref","keys","disposeWatcher","createValue","ScalarNode","EnumNode","undefined","extensionsForKey","extensions","nodes","keyedExtensions","extension","keyExtension","push","Selection","selection","isKeySelection","invariant","keySelections","selections","onSelect","onUnselect","find","off","emitUnselect","toString","Variable","options","assign","updateValue","nullable","updateNullable","validateNode","Disposable","addDisposer","deleteDiposer","disposed","call","uniquify","desiredName","isTaken","unique","differentName","deepJSONEqual","a","b","customCompare","isEqual","length","i","Array","isArray","prototype","PathArray","items","setPrototypeOf","create","element","join","arrayEqual","every","buildArguments","SPACE","SEPARATOR","formatter","args","info","buildKeyed","arg","path","context","sort","keyContext","field","inputs","ofNode","result","build","Boolean","variables","variable","prettify","word","toUpperCase","substr","camelCase","buildVariable","JSON","stringify","indexContext","arrayNode","buildSelections","LINE_SEPARATOR","tree","innerNode","NodeContainer","children","Fragment","buildSelectionTree","FieldSelection","hug","indent","alias","buildAlias","buildArgs","buildChildren","buildFieldSelectionTree","fragmentName","allFragments","fragments","parent","huggedSelections","buildFragmentTree","getAlias","siblingTree","Number","MAX_VALUE","resolveAliases","recurse","originals","updated","recurseObjectTree","cacheKey","indexData","SelectionTree","duplicatedFragments","fragmentTree","getExistingTree","fragment","existingName","t","__decorate","computed","toTree","rootTree","addSelectionToTree","pathToSelection","slice","s","index","findIndex","newTree","keySelection","buildFragments","NEWLINE","from","buildFragment","buildQuery","queryName","selectionPaths","variablesMap","queryHeader","buildVariables","query","Formatter","string","replace","repeat","argsFormatter","selectionsForKey","selectionsFilter","NodeEntry","match","Matchable","instances","exactValue","getByKey","possibleKey","keyIsEqual","FIELD_NAME","merge","cache","mergeScalar","wasNull","isNull","iterateObject","iterateArray","keyedMerge","keyFragments","includes","keyedValue","completeMerge","preferedKey","entry","isKeyable","getKey","keyIsValid","_entry","getKeyFromCache","arrayValue","arrayExtensions","nodeImplementation","getAbstractImplementation","e","childIndex","objectValue","objectData","objectExtensions","mergeObjectKey","filteredSelections","fieldName","fields","_fieldName$match","childField","mergeFiltered","createPath","accessor","currentTransaction","Transaction","begin","end","flush","callbacks","clear","callback","onComplete","afterTransaction","Cache","onRootValueChange","addToEntries","graphNode","_rootValue","transaction","types","nodeEntry","Plugins","Proxy","_","plugins","plugin","isCorrectValue","remove","idx","indexOf","splice","queriesFromStacks","stacks","queryWeights","stack","amount","weights","getWeights","sortedWeights","weight","prevWeight","priority","finalQueries","queriesCount","possibleQueries","highestCount","chosenQuery","Query","defaultQuery","Commit","fetchAccessors","stageUntilValue","resolved","unstage","stage","onValueChange","onResolvedChange","queries","status","NetworkStatus","idle","accessors","onActive","updating","loading","onIdle","values","stackQueries","all","onCommit","promises","async","promise","Promise","console","error","onFetched","Scheduler","interval","startTimer","clearTimer","pushStack","popStack","commit","timer","setTimeout","fetch","clearTimeout","onDataChange","onValueAssociated","prevValue","check","newData","syncValue","getFromValue","withAccessor","isFn","getValue","associateValue","accessorInterceptors","Interceptor","start","onAccessor","listening","stop","ACCESSOR","Symbol","KEYED_REFETCH","memoized","createMemo","Accessor","scheduler","loadExtensions","onInitializeExtensions","_resolved","fragmentToResolve","getData","intercept","prevStatus","_status","onStatusChange","_value","initializeExtensions","addExtensions","ComputableExtension","ComputedExtension","unshift","Abstract","implementations","prevExtensions","FragmentAccessor","redirect","_this$parent","valueless","ctx","setData","log","c","getDefaultFragment","selectionPath","basePath","FieldAccessor","fieldSelection","startResolving","originalAccessor","resetAccessor","removeDisposer","IndexAccessor","RootAccessor","lastAccessor","interceptor","getAccessor","input","FieldsNode","lazyGetters","interceptAccessor","getExtensions","getSelection","REDIRECT","INDEX","GET_KEY","createExtension","keyedBy","StaticExtension","memo","Extension","fragmentKeyedBy","fragmentKey","_this$data2","_this$data3","_this$data4","_entry$match","indexExtension","_this$data5","fieldExtension","_this$data6","isAMatch","super","RegExp","FieldNode","required","parentSelection","_ctx$value","argsFn","parsedArgs","uncallable","argumentlessData","prop","bind","typename","implementation","_ctx$accessor","_fragment$data","_getValue","_ctx$accessor2","Mix","Generic","existingNode","indexValue","proxy","target","arr","isNaN","arrayProperty","InterfaceNode","getMixin","TYPENAME_NODE","matches","keyValue","keyData","fetchQuery","prettifyQueries","responsePromise","response","onFetch","updateInterval","resetTimer","polling","pollAfterInterval","poll","toggle","ofNodes","fragmentAccessor","pattern","_func","_args","isResolved","waitForUpdate","refetch","err","nonIdleAccessors","acc","resolve","reject","finalResult"],"mappings":"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"}