'use strict'
Object.defineProperty(exports, '__esModule', { value: !0 })
var e = require('gqless'),
  t = require('react'),
  r = require('@gqless/utils')
const n = () => (n.value || r.invariant(!1), n.value)
n.value = void 0
const s = (e, t) => {
    const s = n(),
      a = ++s.lastStateIndex
    return (s.state[a] || (s.state[a] = r.createMemo()))(e, t)
  },
  a = t.createContext({ frames: [], inheritance: !0 }),
  o = t.createContext([])
;(exports.Query = ({
  value: r = null,
  allowInheritance: n = !1,
  children: s,
}) => {
  const o = t.useContext(a),
    c = t.useMemo(
      () => ({
        frames:
          null === r
            ? o.frames
            : r instanceof e.Query
            ? [r]
            : (Array.isArray(r) ? r : [r]).map(
                t => new e.Query('string' == typeof t ? t : void 0)
              ),
        inheritance: null === n ? o.inheritance : n,
      }),
      [r, n]
    )
  return t.createElement(a.Provider, { value: c }, s)
}),
  (exports.StackContext = a),
  (exports.graphql = (
    r,
    {
      name: s = (null == r ? void 0 : r.displayName) ||
        (null == r ? void 0 : r.name),
      allowInheritance: c = null,
      seperateRequest: u = !1,
    } = {}
  ) => {
    const l = new e.Query(s, !1),
      i = [],
      d = s => {
        let f
        const m = t.useContext(o),
          p = t.useContext(a),
          h = t.useMemo(
            () =>
              p.inheritance
                ? {
                    ...p,
                    inheritance: null === c ? p.inheritance : c,
                    frames: u ? [l] : [...p.frames, l],
                  }
                : p,
            [u || p]
          )
        n.value = {
          variantFragments: void 0,
          lastStateIndex: -1,
          state: i,
          stack: h,
          accessors: void 0,
          query: l,
          schedulers: void 0,
        }
        const {
          accessors: g,
          schedulers: v,
          startIntercepting: E,
          stopIntercepting: w,
          updateAccessors: y,
        } = (r => {
          const n = t.useMemo(() => new Set(), []),
            s = t.useMemo(() => new Map(), []),
            a = (() => {
              const [r, n] = t.useState(0),
                s = t.useRef(),
                a = t.useRef(!0)
              return (
                t.useEffect(
                  () => () => {
                    var e
                    clearTimeout(
                      null === (e = s.current) || void 0 === e
                        ? void 0
                        : e.timer
                    ),
                      (a.current = !1)
                  },
                  []
                ),
                t =>
                  e.afterTransaction(() => {
                    a.current &&
                      (s.current ||
                        (s.current = {
                          rendered: !1,
                          timer: setTimeout(() => {
                            s.current = void 0
                          }),
                        }),
                      s.current.rendered ||
                        ((s.current.rendered = !0),
                        n(e => e + 1),
                        null == t || t()))
                  })
              )
            })()
          t.useEffect(
            () => () => {
              s.forEach(e => {
                e.forEach(e => e())
              })
            },
            []
          )
          const o = (t => {
            const r = new e.Interceptor(),
              n = new Set(),
              s = new Set()
            return (
              r.onAccessor.listen(e => {
                s.add(e),
                  n.has(e.scheduler) ||
                    (n.add(e.scheduler), e.scheduler.pushStack(...t.frames))
              }),
              {
                interceptor: r,
                schedulers: n,
                interceptedAccessors: s,
                startIntercepting() {
                  r.start()
                },
                stopIntercepting() {
                  r.stop(),
                    n.forEach(e => {
                      e.popStack(...t.frames)
                    })
                },
              }
            )
          })(r)
          return {
            ...o,
            accessors: n,
            updateAccessors() {
              o.interceptedAccessors.forEach(t => {
                n.has(t) ||
                  (n.add(t),
                  s.set(t, [
                    t.onDataChange.listen(() => {
                      a()
                    }),
                    t.onStatusChange.listen((t, r) => {
                      r === e.NetworkStatus.idle &&
                        t !== e.NetworkStatus.idle &&
                        a()
                    }),
                  ]))
              })
              const t = new Set()
              if (
                (n.forEach(r => {
                  if (o.interceptedAccessors.has(r))
                    return void (
                      r.status === e.NetworkStatus.loading && t.add(r)
                    )
                  const a = s.get(r)
                  a && (s.delete(r), a.forEach(e => e())), n.delete(r)
                }),
                t.size)
              )
                return new Promise(e => {
                  t.forEach(r => {
                    r.onStatusChange.then(() => {
                      t.delete(r), t.size || e()
                    })
                  })
                })
            },
          }
        })(h)
        Object.assign(n.value, { accessors: g, schedulers: v })
        const {
          variantFragments: S,
          startResolving: x,
          stopResolving: A,
          getRenderVariants: k,
        } = (() => {
          const r = t.useContext(o),
            n = new Map(),
            s = []
          return {
            variantFragments: n,
            startResolving() {
              r.forEach(([t, r]) => {
                const n =
                  t.get(e => e.selection === r) || new e.FragmentAccessor(t, r)
                s.push(n.startResolving())
              })
            },
            stopResolving() {
              s.forEach(e => e())
            },
            getRenderVariants() {
              let t = []
              return (
                n.forEach((r, n) => {
                  if (n.value || n.status === e.NetworkStatus.idle) return
                  if (!t.length) return void r.forEach(e => t.push([[n, e]]))
                  const s = []
                  r.forEach(e => {
                    for (let r = 0; r < t.length; r++) s.push([...t[r], [n, e]])
                  }),
                    (t = s)
                }),
                t
              )
            },
          }
        })()
        Object.assign(n.value, { variantFragments: S })
        try {
          x(), E(), (f = r(s))
        } catch (e) {
          throw e
        } finally {
          ;(n.value = void 0), w(), A()
        }
        if (S.size) {
          const e = k()
          if (e.length)
            return e.map((e, r) =>
              t.createElement(
                o.Provider,
                { key: r, value: [...m, ...e] },
                t.createElement(d, Object.assign({}, s))
              )
            )
        }
        f = t.createElement(a.Provider, { value: h }, f)
        const C = y()
        if (C) {
          let e = !1
          return (
            C.then(() => (e = !0)),
            t.createElement(
              t.Fragment,
              null,
              f,
              t.createElement(() => {
                if (e) return null
                throw C
              }, null)
            )
          )
        }
        return f
      }
    return (
      (d.displayName = `GraphQLComponent(${s || 'Component'})`),
      (d.query = l),
      d
    )
  }),
  (exports.ofType = function(t, r) {
    try {
      const { variantFragments: s } = n(),
        a = e.getAccessor(t),
        o = e.getAbstractImplementation(a.node, r)
      if (o) {
        const e = a.getDefaultFragment(o)
        s.has(a) || s.set(a, new Set()), s.get(a).add(e)
      }
    } catch {}
    return t.__typename === r
  }),
  (exports.useFragment = function(r, n, a) {
    let o = e.getAccessor(r)
    o instanceof e.FragmentAccessor && (o = o.parent)
    const c = t.useMemo(() => {
        const t = o.node instanceof e.NodeContainer ? o.node.innerNode : o.node
        if (n) {
          const r = e.getAbstractImplementation(t, n)
          if (r) return r
        }
        return t
      }, [o.node, n]),
      u = s(() => new e.Fragment(c, a), [c])
    return (
      t.useMemo(() => {
        a && (u.name = a)
      }, [u, a]),
      t.useMemo(() => e.fragmentOn(o, u), [o, u])
    )
  }),
  (exports.usePoll = (r, s, a = !0) => {
    const o = e.getAccessor(r),
      { stack: c } = n(),
      [u, l] = t.useState(a),
      i = t.useMemo(() => new e.Poller(o, s, c.frames), [o])
    return (
      t.useEffect(() => () => i.toggle(!1), [o]),
      t.useEffect(() => {
        i.updateInterval(s)
      }, [s]),
      t.useEffect(() => {
        i.toggle(u)
      }, [i, u]),
      [
        u,
        (e = !u) => {
          l(e)
        },
      ]
    )
  }),
  (exports.useTracked = () => {
    const { stack: e, schedulers: t } = n()
    return r => {
      try {
        return t.forEach(t => t.pushStack(...e.frames)), r()
      } finally {
        t.forEach(t => t.popStack(...e.frames))
      }
    }
  }),
  (exports.useVariable = function(r, n, a) {
    const o = 'boolean' == typeof n ? n : void 0,
      c = void 0 !== a ? a : 'string' == typeof n ? n : void 0,
      u = s(() => new e.Variable(r, { name: c, nullable: o }), [])
    return (
      t.useEffect(() => {
        void 0 !== o && u.updateNullable(o)
      }, [u, o]),
      t.useEffect(() => {
        u.updateValue(r)
      }, [u, r]),
      u
    )
  })
//# sourceMappingURL=react.cjs.production.min.js.map
